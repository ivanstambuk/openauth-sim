#!/usr/bin/env bash
set -euo pipefail

# -----------------------------------------------------------------------------
# Pre-commit quality gate for OpenAuth Simulator
#   1. Collect staged files and verify prerequisites
#   2. Guard against oversized/binary artefacts
#   3. Run Gradle formatting (Palantir Java Format 2.78.0) + targeted tests + check (sans full test suite)
#   4. Execute secret scanning (gitleaks)
# -----------------------------------------------------------------------------

ROOT_DIR=$(git rev-parse --show-toplevel)
MAX_FILE_SIZE_BYTES=$((1024 * 1024)) # 1 MB

log() { echo "[pre-commit] $*" >&2; }
die() { log "$*"; exit 1; }
require_command() {
  local binary=$1
  local guidance=$2
  command -v "$binary" >/dev/null 2>&1 || die "$guidance"
}
human_readable_size() {
  local bytes=$1
  if command -v numfmt >/dev/null 2>&1; then
    numfmt --to=iec --suffix=B "$bytes"
  else
    printf '%sB' "$bytes"
  fi
}


run_gradle_with_retry() {
  local description=$1
  shift
  local -a gradle_args=("$@")
  log "$description"

  local output=""
  local exit_code=0
  set +e
  output=$("$ROOT_DIR"/gradlew --no-daemon "${gradle_args[@]}" 2>&1)
  exit_code=$?
  set -e
  if [[ -n $output ]]; then
    printf '%s\n' "$output"
  fi

  if (( exit_code == 0 )); then
    return 0
  fi

  local stale_signature='Spotless JVM-local cache is stale. Regenerate the cache with'

  if grep -Fq "$stale_signature" <<<"$output"; then
    local cache_dir="$ROOT_DIR/.gradle/configuration-cache"
    log "Detected Spotless stale cache; removing '$cache_dir' and retrying once."
    rm -rf "$cache_dir"

    set +e
    local retry_output
    local retry_exit=0
    retry_output=$("$ROOT_DIR"/gradlew --no-daemon "${gradle_args[@]}" 2>&1)
    retry_exit=$?
    set -e
    if [[ -n $retry_output ]]; then
      printf '%s\n' "$retry_output"
    fi

    if (( retry_exit == 0 )); then
      log "Spotless retry succeeded after cache clear."
      return 0
    else
      log "Spotless retry failed after cache clear (exit $retry_exit)."
      return $retry_exit
    fi
  fi

  return $exit_code
}

collect_staged_files() {
  mapfile -t STAGED_FILES < <(git diff --cached --name-only --diff-filter=AM)
  if (( ${#STAGED_FILES[@]} == 0 )); then
    log "No staged changes detected; skipping hook."
    exit 0
  fi
}

validate_environment() {
  [[ -n ${JAVA_HOME:-} ]] || die "JAVA_HOME must point to a Java 17 JDK before committing."
  require_command file "Install 'file' command (usually part of util-linux) before committing."
}

enforce_staged_file_guards() {
  local -a large_files=()
  local -a binary_files=()
  local file size_bytes mime_type

  for file in "${STAGED_FILES[@]}"; do
    [[ -f "$file" ]] || continue

    size_bytes=$(wc -c <"$file")
    if (( size_bytes > MAX_FILE_SIZE_BYTES )); then
      large_files+=("$file ($(human_readable_size "$size_bytes"))")
    fi

    mime_type=$(file -b --mime "$file" 2>/dev/null || echo "application/octet-stream")
    if [[ $mime_type == image/* ]]; then
      continue
    fi
    if [[ $mime_type == application/json* ]]; then
      continue
    fi
    if [[ $mime_type == application/javascript* || $mime_type == text/javascript* ]]; then
      continue
    fi
    if [[ $mime_type == application/x-yaml* || $mime_type == text/yaml* ]]; then
      continue
    fi
    if [[ $mime_type == *"charset=binary"* || $mime_type == application/* ]]; then
      binary_files+=("$file ($mime_type)")
    fi
  done

  if (( ${#large_files[@]} > 0 )); then
    log "The following staged files exceed the 1 MB limit:"
    printf '  - %s\n' "${large_files[@]}" >&2
    die "Remove or split large files before committing."
  fi

  if (( ${#binary_files[@]} > 0 )); then
    log "Binary files detected in the staged changes:"
    printf '  - %s\n' "${binary_files[@]}" >&2
    die "Remove generated artifacts (e.g., .class, .jar) before committing."
  fi
}

clear_configuration_cache() {
  local cache_dir="$ROOT_DIR/.gradle/configuration-cache"
  if [[ -d $cache_dir ]]; then
    log "Clearing Gradle configuration cache before quality pipeline."
    rm -rf "$cache_dir"
  fi
}

run_gradle_pipeline() {
  clear_configuration_cache
  run_gradle_with_retry "Warming Gradle configuration cache" help --configuration-cache

  run_gradle_with_retry "Running Gradle spotlessApply (Palantir Java Format 2.78.0)" spotlessApply

  declare -gA TEST_TASKS=()
  for file in "${STAGED_FILES[@]}"; do
    case "$file" in
      core/src/*) TEST_TASKS[":core:test"]=1 ;;
      cli/src/*) TEST_TASKS[":cli:test"]=1 ;;
      rest-api/src/*) TEST_TASKS[":rest-api:test"]=1 ;;
      ui/src/*) TEST_TASKS[":ui:test"]=1 ;;
    esac
  done

  if (( ${#TEST_TASKS[@]} > 0 )); then
    run_gradle_with_retry "Running targeted test suites: ${!TEST_TASKS[@]}" "${!TEST_TASKS[@]}"
  else
    log "No staged production code changes detected; skipping targeted tests."
  fi

  run_gradle_with_retry "Generating aggregated JaCoCo report" jacocoAggregatedReport
  run_gradle_with_retry "Verifying JaCoCo thresholds" jacocoCoverageVerification

  run_gradle_with_retry \
    "Running Gradle check (skipping heavy coverage tasks)" \
    check -Ppit.skip=true -x test -x jacocoAggregatedReport -x jacocoCoverageVerification
}

run_mutation_suite() {
  run_gradle_with_retry "Running mutation test suite" mutationTest
}

run_external_scanners() {
  require_command gitleaks "Install gitleaks: https://github.com/gitleaks/gitleaks#installation"
  log "Running gitleaks secret scan"
  gitleaks protect --no-banner --redact --staged --source "$ROOT_DIR"

}

main() {
  collect_staged_files
  validate_environment
  enforce_staged_file_guards
  run_gradle_pipeline
  run_mutation_suite
  run_external_scanners
  log "All pre-commit checks passed."
}

main "$@"
