<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Protocol Info Surface Demo</title>
    <link rel="stylesheet" href="protocol-info.css" />
    <style>
      body {
        font-family: "Inter", "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: #050b16;
        color: #e2ecf9;
        margin: 0;
        padding: 2.5rem;
        min-height: 100vh;
        display: flex;
        justify-content: center;
      }
      main {
        max-width: 960px;
        width: 100%;
      }
      h1 {
        margin-top: 0;
      }
      .demo-protocols {
        display: inline-flex;
        align-items: center;
        gap: 0.6rem;
        margin-bottom: 1.5rem;
        padding: 0.5rem 0.6rem;
        border-radius: 999px;
        background: rgba(6, 17, 32, 0.82);
        border: 1px solid rgba(22, 211, 243, 0.28);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35), inset 0 0 0 1px rgba(22, 211, 243, 0.08);
      }
      .demo-protocols__tab {
        padding: 0.6rem 1.1rem;
        border-radius: 0.625rem;
        border: 1px solid rgba(22, 211, 243, 0.35);
        background: rgba(22, 211, 243, 0.12);
        color: #16d3f3;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease;
      }
      .demo-protocols__tab:hover,
      .demo-protocols__tab:focus-visible {
        background: rgba(22, 211, 243, 0.24);
        color: #4fffc8;
        outline: none;
      }
      .demo-protocols__tab--active {
        background: rgba(22, 211, 243, 0.22);
        color: #4fffc8;
        box-shadow: 0 0 1.4rem rgba(22, 211, 243, 0.35);
      }
      .demo-protocols .protocol-info-trigger {
        margin-left: 0.4rem;
        border-left: 1px solid rgba(22, 211, 243, 0.24);
        background: rgba(22, 211, 243, 0.12);
      }
      .demo-active-protocol {
        margin-bottom: 1.5rem;
        color: rgba(226, 236, 249, 0.72);
      }
    </style>
  </head>
  <body>
    <main id="protocol-info-demo-root">
      <h1>Protocol Info Surface Demo</h1>
      <p class="demo-active-protocol">
        Trigger the surface to explore protocol guidance. Use Shift + ? to toggle the drawer.
      </p>
      <div class="demo-protocols">
        <button type="button" class="demo-protocols__tab demo-protocols__tab--active" data-demo-protocol="ocra">OCRA</button>
        <button type="button" class="demo-protocols__tab" data-demo-protocol="hotp">HOTP</button>
        <button type="button" class="demo-protocols__tab" data-demo-protocol="totp">TOTP</button>
        <button type="button" class="demo-protocols__tab" data-demo-protocol="emv">EMV / CAP</button>
        <button type="button" class="demo-protocols__tab" data-demo-protocol="fido2">FIDO2 / WebAuthn</button>
        <button type="button" class="demo-protocols__tab" data-demo-protocol="eudi-openid4vp">
          EUDIW OpenID4VP 1.0
        </button>
        <button type="button" class="demo-protocols__tab" data-demo-protocol="eudi-iso-18013-5">
          EUDIW ISO/IEC 18013-5
        </button>
        <button type="button" class="demo-protocols__tab" data-demo-protocol="eudi-siopv2">
          EUDIW SIOPv2
        </button>
        <button
          type="button"
          class="protocol-info-trigger"
          data-protocol="ocra"
          aria-label="Protocol info"
          aria-haspopup="dialog"
          aria-controls="protocol-info-surface"
          aria-expanded="false"
        >
          <span aria-hidden="true">i</span>
        </button>
      </div>

      <div
        class="protocol-info-backdrop"
        data-testid="protocol-info-backdrop"
        data-mode="drawer"
        data-visible="false"
        hidden="hidden"
      ></div>
      <aside
        id="protocol-info-surface"
        class="protocol-info-surface"
        data-testid="protocol-info-surface"
        data-open="false"
        data-surface-mode="drawer"
        data-active-protocol="ocra"
        role="complementary"
        aria-labelledby="protocol-info-title"
        hidden="hidden"
      >
        <header class="protocol-info-header">
          <div class="protocol-info-header__titles">
            <p class="protocol-info-subtitle" data-testid="protocol-info-subtitle">Protocol guidance</p>
            <h2 class="protocol-info-title" data-testid="protocol-info-title">OCRA (OATH Challenge-Response Algorithm)</h2>
          </div>
          <div class="protocol-info-header__actions">
            <button
              type="button"
              class="protocol-info-action"
              data-testid="protocol-info-expand"
              aria-label="Expand to modal"
            >
              Expand
            </button>
            <button
              type="button"
              class="protocol-info-action protocol-info-action--primary"
              data-testid="protocol-info-close"
              aria-label="Close protocol info"
            >
              Close
            </button>
          </div>
        </header>
        <div class="protocol-info-body">
          <div class="protocol-info-summary" data-testid="protocol-info-summary"></div>
          <div class="protocol-info-accordion" data-testid="protocol-info-accordion"></div>
        </div>
      </aside>
    </main>

    <script type="application/json" id="protocol-info-data">
      {
        "protocols": {
          "ocra": {
            "title": "OCRA (OATH Challenge-Response Algorithm)",
            "subtitle": "Challenge-response credential operations",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "OCRA (RFC 6287) derives one-time responses by hashing a keyed secret with a challenge payload, enabling transaction signing and high-assurance verification windows.",
                  "The simulator implements the suite-driven descriptor model used across MapDB-backed credential stores and facade integrations."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Select an RFC 6287 suite that defines data inputs and truncation rules.",
                  "Collect inputs (counter, timestamp, challenge, PIN, session) and normalise to byte arrays.",
                  "Concatenate the suite-defined data fields and compute an HMAC using the shared secret.",
                  "Truncate the HMAC response to the requested digit length and format as the final OTP.",
                  "Validate by recomputing the response and comparing constant-time across allowed drift windows."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Suites use the format OCRAnnn-h-m, where data descriptors declare counter (C), question (Q), password (P), session (S), and timestamp (T) inputs.",
                  "Challenge questions accept Hex, Alphanumeric, or Numeric payloads; simulator inputs request the canonical representation needed for each suite.",
                  "Responses truncate to 4–10 digits; the simulator exposes 8 and 10 digit defaults for operator workflows."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "Rotate shared secrets when challenge payloads leak or counters desynchronise beyond replay windows.",
                  "Reject challenges that exceed maximum length (512 bytes) to avoid resource exhaustion.",
                  "Protect transport of challenge payloads; MITM modification yields fraudulent signatures."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "RFC 6287 – OCRA", "url": "https://www.rfc-editor.org/rfc/rfc6287" },
                  { "label": "NIST SP 800-63B", "url": "https://pages.nist.gov/800-63-3/sp800-63b.html" },
                  { "label": "OpenAuth Simulator OCRA samples", "url": "https://example.com/docs/ocra-samples" }
                ]
              }
            ]
          },
          "hotp": {
            "title": "HOTP (HMAC-Based One-Time Password)",
            "subtitle": "Event counter driven OTP",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "HOTP (RFC 4226) increments a moving counter shared between client and verifier to derive HMAC-based OTP values.",
                  "The simulator will expose counter management helpers once HOTP issuance ships."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Derive a counter value shared between client and server.",
                  "Compute HMAC-SHA-1 over the 8-byte counter and truncate per RFC 4226 dynamic truncation.",
                  "Compare OTP values within a resynchronisation window to tolerate drift."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Counters increment monotonically; resets demand secret rotation.",
                  "Digits commonly configured at 6 or 8; RFC 4226 permits 6–10.",
                  "Secrets are Base32-encoded for provisioning (per Key URI format)."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "High drift windows expand brute-force exposure; keep look-ahead ≤30.",
                  "Persist counter checkpoints to avoid replay when devices desynchronise.",
                  "Store HOTP secrets encrypted at rest; treat as high-value credentials."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "RFC 4226 – HOTP", "url": "https://www.rfc-editor.org/rfc/rfc4226" },
                  { "label": "Key URI Format", "url": "https://github.com/google/google-authenticator/wiki/Key-Uri-Format" }
                ]
              }
            ]
          },
          "totp": {
            "title": "TOTP (Time-Based One-Time Password)",
            "subtitle": "Time-stepped OTP",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "TOTP (RFC 6238) derives moving OTP values from the Unix timestamp and a shared secret, using dynamic truncation to produce human-readable codes.",
                  "Future simulator work will surface drift tolerance controls and telemetry around verification results."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Choose a time step (typically 30 seconds) and compute the moving counter floor(timestamp / step).",
                  "Derive an HMAC digest using the shared secret and the moving counter.",
                  "Apply dynamic truncation to obtain a 6–8 digit OTP.",
                  "Verifier recomputes OTP within an allowed drift window to tolerate clock skew."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Common steps: 30s for user authentication, 60s for slower backends.",
                  "Secrets encoded with Base32 for compatibility with OTP provisioning URIs.",
                  "Drift window typically ±1 step; expand cautiously for high latency networks."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "Sync server clocks using NTP to keep drift within tolerances.",
                  "Invalidate codes after single use to mitigate replay.",
                  "Alert operators when drift window expands beyond policy thresholds."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "RFC 6238 – TOTP", "url": "https://www.rfc-editor.org/rfc/rfc6238" },
                  { "label": "NIST SP 800-63B", "url": "https://pages.nist.gov/800-63-3/sp800-63b.html" }
                ]
              }
            ]
          },
          "emv": {
            "title": "EMV / CAP",
            "subtitle": "Chip authentication program",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "EMV/CAP authenticators compute transaction signatures with EMV-grade smart cards and offline terminals, producing short CAP codes for retail approval flows.",
                  "Simulator coverage will model issuer scripts, ARQC verification, and CAP conversion."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Terminal reads card data, authenticates using static or dynamic data authentication.",
                  "Issuer scripts instruct the card to compute an ARQC using transaction data.",
                  "CAP converts ARQC hashes into human-readable response codes for operator approval."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "ARQC inputs: transaction counter, amount, currency, unpredictable number, terminal country code.",
                  "CAP calculators display 8-digit codes; verification uses issuer-provisioned hashing schemes.",
                  "Terminal verification results determine CVM outcomes (signature, PIN, offline)."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "Protect issuer master keys; compromise enables transaction replay and counterfeit cards.",
                  "Monitor ATC rollovers and unexpected terminal UN values.",
                  "Require CAP operator dual control for high-risk transaction confirmation."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "EMV Book 2", "url": "https://www.emvco.com/emv-technologies/contact/" },
                  { "label": "CAP specification", "url": "https://www.emvco.com/emv-technologies/3-d-secure/" }
                ]
              }
            ]
          },
          "fido2": {
            "title": "FIDO2 / WebAuthn",
            "subtitle": "Phishing-resistant public-key authentication",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "FIDO2 pairs WebAuthn (client/platform authenticators) with CTAP2 devices to deliver phishing-resistant, origin-bound authentication.",
                  "Simulator flows will expose ceremony walkthroughs and metadata-driven credential policies."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Relying party challenges the client via WebAuthn create/get ceremonies.",
                  "Authenticator signs client data (origin, challenge, flags) using resident keys or discoverable credentials.",
                  "Relying party verifies signature, checks attestation/metadata, and stores credential IDs for subsequent logins."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Relying parties specify `pubKeyCredParams`, authenticator selection criteria, and attestation preference.",
                  "ClientDataJSON encodes challenge, origin, and Cross-Origin flag.",
                  "AuthenticatorData conveys AAGUID, sign count, flags, and optional attested credential data."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "Enforce RP ID hash checks to prevent look-alike domain phishing.",
                  "Track signature counters to detect cloned authenticators.",
                  "Validate attestation metadata or prefer self-attestation if privacy bound."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "WebAuthn Level 2", "url": "https://www.w3.org/TR/webauthn-2/" },
                  { "label": "FIDO2 CTAP2", "url": "https://fidoalliance.org/specs/fido-v2.3-rd-20220621/fido-client-to-authenticator-protocol-v2.3-rd-20220621.html" }
                ]
              }
            ]
          },
          "eudi-openid4vp": {
            "title": "EUDIW OpenID4VP 1.0",
            "subtitle": "Verifiable presentation over OpenID Connect",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "OpenID4VP lets verifiers request verifiable credentials from EUDI wallets using OpenID Connect flows, binding presentations to relying party sessions.",
                  "Simulator content will illustrate request_uri resolution, presentation submissions, and trust frameworks."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Verifier publishes a presentation definition accessible via request_uri.",
                  "Wallet resolves the definition, assembles verifiable credentials, and signs submission data.",
                  "Verifier validates credential proofs, applies trust list policies, and issues an authorization response."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Presentation submission objects map input descriptors to credential paths.",
                  "request_uri payloads embed the presentation definition alongside client metadata.",
                  "Wallet attestation captures device, software version, and key attestation material where required."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "Enforce audience binding between request_uri and presentation submission.",
                  "Rotate presentation exchange nonces per session.",
                  "Validate descriptor_map entries to guard against mismatched credentials."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "OpenID4VP 1.0", "url": "https://openid.net/specs/openid-4-verifiable-presentations-1_0.html" },
                  { "label": "EUDI Architecture", "url": "https://digital-strategy.ec.europa.eu/en/policies/eudi-wallet" }
                ]
              }
            ]
          },
          "eudi-iso-18013-5": {
            "title": "EUDIW ISO/IEC 18013-5",
            "subtitle": "Mobile driving licence presentations",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "ISO/IEC 18013-5 governs mobile driving licence (mDL) credential presentation workflows leveraged by the EUDI wallet.",
                  "Future simulator flows will generate device engagement and reader session payloads."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Reader and device establish secure session via NFC, BLE, or QR engagement.",
                  "Reader sends a device request listing data elements and authentication options.",
                  "Device signs response items and returns a Mobile Security Object (MSO)."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Device engagement data encodes reader public keys and session IDs.",
                  "MSO contains metadata version, digest algorithm, and signed data element digests.",
                  "Presentation responses carry device signatures plus reader authentication status."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "Enforce per-session key confirmation to block relay attacks.",
                  "Limit disclosed data elements to the minimum requested scope.",
                  "Verify issuer certificate chains per country-specific trust lists."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "ISO/IEC 18013-5", "url": "https://www.iso.org/standard/69084.html" },
                  { "label": "ISO/IEC 23220-4 draft", "url": "https://www.iso.org/committee/45144.html" }
                ]
              }
            ]
          },
          "eudi-siopv2": {
            "title": "EUDIW SIOPv2",
            "subtitle": "Self-issued OpenID Provider",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "SIOPv2 lets wallets act as self-issued OpenID Providers, returning ID token responses scoped to verifier requests.",
                  "Simulator coverage plans to visualise DID document resolution and credential binding."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Verifier issues an OIDC authentication request referencing self-issued client metadata.",
                  "Wallet resolves its DID document, constructs an ID token with requested claims, and signs using the DID key.",
                  "Verifier validates the DID signature and correlates presentation responses where required."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Self-issued clients signal subject identifiers via did: or jkt claims.",
                  "Nonce and state parameters bind the authentication to the verifier session.",
                  "Responses may embed verifiable presentations via presentation_submission."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "Validate DID key agreement and rotate keys when compromised.",
                  "Reject unsigned or weakly signed ID tokens (alg=none).",
                  "Mitigate correlation: provide pairwise identifiers for each verifier relying party."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "OpenID SIOPv2", "url": "https://openid.net/specs/openid-connect-self-issued-v2-1_0.html" },
                  { "label": "Decentralized Identifiers (DID Core)", "url": "https://www.w3.org/TR/did-core/" }
                ]
              }
            ]
          }
        }
      }
    </script>
    <script src="protocol-info.js"></script>
    <script>
      (function () {
        var demoRoot = document.getElementById('protocol-info-demo-root');
        var status = demoRoot.querySelector('.demo-active-protocol');
        var tabs = Array.prototype.slice.call(
          document.querySelectorAll('[data-demo-protocol]')
        );
        var trigger = document.querySelector('.protocol-info-trigger');

        function setActive(protocol, options) {
          tabs.forEach(function (tab) {
            var isActive = tab.getAttribute('data-demo-protocol') === protocol;
            tab.classList.toggle('demo-protocols__tab--active', isActive);
          });
          if (trigger) {
            trigger.setAttribute('data-protocol', protocol);
          }
          if (status) {
            status.textContent = 'Active protocol: ' + protocol.toUpperCase();
          }
          if (window.ProtocolInfo) {
            window.ProtocolInfo.setProtocol(protocol, options || { notifyHost: true });
          }
        }

        tabs.forEach(function (tab) {
          tab.addEventListener('click', function () {
            var protocol = tab.getAttribute('data-demo-protocol');
            setActive(protocol, { notifyHost: true });
          });
        });

        window.ProtocolInfo.mount({
          root: demoRoot,
          onProtocolActivated: function (protocol) {
            setActive(protocol, { notifyHost: false });
          },
        });

        setActive('ocra');
      })();
    </script>
  </body>
</html>
