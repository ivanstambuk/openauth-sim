<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>OCRA Evaluation</title>
    <link rel="stylesheet" th:href="@{/ui/ocra/console.css}" />
  </head>
  <body>
    <main aria-labelledby="console-heading">
      <h1 id="console-heading">OCRA Evaluation Console</h1>
      <p id="console-summary" class="summary">
        Submit a stored credential or inline secret to evaluate an OCRA response via the REST API.
        Required fields are marked and secrets are never echoed back.
      </p>

      <section aria-labelledby="evaluate-heading" class="card-shell">
        <div class="section-columns">
          <div>
            <h2 id="evaluate-heading" class="section-title">Evaluate an OCRA response</h2>
            <form
                action="#"
                aria-describedby="console-summary"
                data-testid="ocra-evaluate-form"
                class="evaluation-form"
                th:attr="data-evaluate-endpoint=${evaluationEndpoint}"
              >
            <input type="hidden" name="_csrf" th:value="${csrfToken}" />

            <fieldset
              data-testid="mode-toggle"
              aria-describedby="mode-help"
              class="mode-toggle"
            >
              <legend>Choose evaluation mode</legend>
              <div class="mode-option">
                <input
                  type="radio"
                  id="mode-inline"
                  name="mode"
                  value="inline"
                  th:checked="${form.mode == 'inline'}"
                />
                <label for="mode-inline">Inline parameters</label>
                <p id="inline-mode-hint" class="hint">
                  Provide the OCRA suite and shared secret manually. Use this for quick diagnostics.
                </p>
              </div>
              <div class="mode-option">
                <input
                  type="radio"
                  id="mode-credential"
                  name="mode"
                  value="credential"
                  th:checked="${form.mode == 'credential'}"
                />
                <label for="mode-credential">Stored credential</label>
                <p id="credential-mode-hint" class="hint">
                  Reference a credential already persisted by the simulator. Secrets remain hidden.
                </p>
              </div>
              <p id="mode-help" class="hint">Only one mode can be active for each submission.</p>
            </fieldset>

            <section
              id="inline-parameters"
              data-mode-section="inline"
              th:attr="hidden=${form.mode == 'credential'} ? 'hidden' : null, aria-hidden=${form.mode == 'credential'}"
              aria-labelledby="inline-heading"
              class="field-grid"
            >
              <h3 id="inline-heading">Inline parameters</h3>
              <p class="hint" id="inline-describe">
                Enter the suite and shared secret exactly as hex strings. Secrets remain visible after
                evaluation so operators can reuse verification data; clear the field manually if
                needed.
              </p>
              <div>
                <label for="policyPreset">Load a sample vector</label>
                <select
                  id="policyPreset"
                  name="policyPreset"
                  th:value="${form.policyPreset}"
                  data-testid="inline-policy-select"
                >
                  <option value="">Select a sample</option>
                  <option
                    th:each="preset : ${policyPresets}"
                    th:value="${preset.key}"
                    th:text="${preset.label}"
                  ></option>
                </select>
                <p class="hint">Selecting a preset fills the inline fields with illustrative data.</p>
              </div>
              <div>
                <label for="suite">Suite</label>
                <input
                  id="suite"
                  name="suite"
                  type="text"
                  autocomplete="off"
                  th:value="${form.suite}"
                  th:attr="aria-describedby=${'inline-describe'},required=${form.inlineMode} ? 'required' : null"
                  data-inline-required="true"
                />
              </div>
              <div>
                <label for="sharedSecretHex">Shared Secret (hex)</label>
                <input
                  id="sharedSecretHex"
                  name="sharedSecretHex"
                  type="text"
                  autocomplete="off"
                  th:value="${form.sharedSecretHex}"
                  placeholder="Hex encoded secret"
                  th:attr="aria-describedby=${'inline-describe'},required=${form.inlineMode} ? 'required' : null"
                  data-inline-required="true"
                />
              </div>
              <div>
                <label for="pinHashHex">PIN hash (hex, optional)</label>
                <input
                  id="pinHashHex"
                  name="pinHashHex"
                  type="text"
                  autocomplete="off"
                  th:value="${form.pinHashHex}"
                  placeholder="Optional SHA hash of PIN"
                />
              </div>
            </section>

            <section
              id="credential-parameters"
              data-mode-section="credential"
              th:attr="hidden=${form.mode != 'credential'} ? 'hidden' : null, aria-hidden=${form.mode != 'credential'}"
              aria-labelledby="credential-heading"
              class="field-grid"
            >
              <h3 id="credential-heading">Stored credential</h3>
              <p class="hint" id="credential-describe">
                Provide the credential identifier to reuse the stored suite and secret managed by the
                simulator.
              </p>
              <div>
                <label for="credentialId">Credential identifier</label>
                <input
                  id="credentialId"
                  name="credentialId"
                  type="text"
                  autocomplete="off"
                  th:value="${form.credentialId}"
                  aria-describedby="credential-describe"
                  th:attr="required=${form.credentialMode} ? 'required' : null"
                  data-credential-required="true"
                />
              </div>
            </section>

          <section aria-labelledby="parameters-heading" class="request-parameters">
            <div class="stack-sm">
              <h3 id="parameters-heading">Request parameters</h3>
              <p class="hint" id="parameters-hint">
                Optional fields match the REST API contract. Leave blank to accept backend defaults.
              </p>
              <button
                type="button"
                class="advanced-toggle"
                data-testid="ocra-advanced-toggle"
                aria-controls="advanced-parameters"
                aria-expanded="false"
                data-expanded="false"
              >
                <svg viewBox="0 0 16 16" role="presentation" focusable="false">
                  <path
                    fill="currentColor"
                    d="M8 11a.75.75 0 0 1-.53-.22l-4-4a.75.75 0 1 1 1.06-1.06L8 9.19l3.47-3.47a.75.75 0 0 1 1.06 1.06l-4 4A.75.75 0 0 1 8 11Z"
                  />
                </svg>
                Advanced parameters
              </button>
            </div>

            <div class="field-grid request-primary-grid">
              <div>
                <label for="challenge">Challenge</label>
                <input
                  id="challenge"
                  name="challenge"
                  type="text"
                  th:value="${form.challenge}"
                  autocomplete="off"
                  aria-describedby="parameters-hint"
                />
              </div>
              <div>
                <label for="counter">Counter</label>
                <input
                  id="counter"
                  name="counter"
                  type="number"
                  min="0"
                  th:value="${form.counter}"
                  autocomplete="off"
                />
              </div>
            </div>

            <div
              id="advanced-parameters"
              class="advanced-panel field-grid"
              data-testid="ocra-advanced-panel"
              data-open="false"
            >
              <div>
                <label for="clientChallenge">Client challenge</label>
                <input
                  id="clientChallenge"
                  name="clientChallenge"
                  type="text"
                  th:value="${form.clientChallenge}"
                  autocomplete="off"
                />
              </div>
              <div>
                <label for="serverChallenge">Server challenge</label>
                <input
                  id="serverChallenge"
                  name="serverChallenge"
                  type="text"
                  th:value="${form.serverChallenge}"
                  autocomplete="off"
                />
              </div>
              <div>
                <label for="sessionHex">Session (hex)</label>
                <textarea
                  id="sessionHex"
                  name="sessionHex"
                  rows="3"
                  th:text="${form.sessionHex}"
                  aria-describedby="parameters-hint"
                ></textarea>
              </div>
              <div>
                <label for="timestampHex">Timestamp (hex)</label>
                <input
                  id="timestampHex"
                  name="timestampHex"
                  type="text"
                  th:value="${form.timestampHex}"
                  autocomplete="off"
                />
              </div>
            </div>
          </section>

            <button type="button" class="button-primary" data-testid="ocra-evaluate-button">
              Evaluate response
            </button>
            </form>
          </div>
          <div class="status-column">
            <section
              data-testid="ocra-result-panel"
              aria-live="polite"
              aria-labelledby="result-heading"
              hidden="hidden"
              class="result-panel"
            >
              <h2 id="result-heading">Evaluation result</h2>
              <p data-testid="ocra-otp">
                OTP:
                <strong data-testid="ocra-otp-value"></strong>
              </p>
              <dl data-testid="ocra-telemetry-summary" class="result-metadata">
                <dt>Status</dt>
                <dd data-testid="ocra-status-value"></dd>
                <dt>Sanitized</dt>
                <dd data-testid="ocra-sanitized-flag"></dd>
                <dt>Suite</dt>
                <dd data-testid="ocra-suite-value"></dd>
              </dl>
            </section>

            <section
              data-testid="ocra-error-panel"
              aria-live="assertive"
              role="alert"
              aria-labelledby="error-heading"
              hidden="hidden"
              class="error-panel"
            >
              <div>
                <h2 id="error-heading">Evaluation failed</h2>
                <p data-testid="ocra-error-primary"></p>
                <p class="hint" data-testid="ocra-error-secondary"></p>
              </div>
            </section>
          </div>
        </div>
      </section>
    </main>

    <script
      id="ocra-policy-presets"
      type="application/json"
      th:utext="${policyPresetJson}"
    ></script>

    <script th:inline="javascript" data-testid="ocra-fetch-script">
      (function () {
        const modeInputs = document.querySelectorAll('input[name="mode"]');
        const sections = document.querySelectorAll('[data-mode-section]');
        const inlineRequired = document.querySelectorAll('[data-inline-required]');
        const credentialRequired = document.querySelectorAll('[data-credential-required]');
        const policySelect = document.getElementById('policyPreset');
        const inlinePresetElement = document.getElementById('ocra-policy-presets');
        const form = document.querySelector('[data-testid="ocra-evaluate-form"]');
        const submitButton = form
          ? form.querySelector('[data-testid="ocra-evaluate-button"]')
          : null;
        const inlinePresets =
          inlinePresetElement && inlinePresetElement.textContent
            ? JSON.parse(inlinePresetElement.textContent)
            : [];
        const presetMap = inlinePresets.reduce(function (acc, preset) {
          if (
            preset &&
            typeof preset.key === 'string' &&
            preset.sample &&
            typeof preset.sample === 'object'
          ) {
            acc[preset.key] = preset.sample;
          }
          return acc;
        }, Object.create(null));
        window.__ocraPresetMap = presetMap;
        const FRIENDLY_ERRORS = Object.freeze({
          credential_not_found: 'Stored credential could not be found. Check the identifier.',
          credential_conflict:
            'Multiple credentials matched this identifier. Use a more specific ID or clean up duplicates.',
          invalid_shared_secret: 'Shared secret is invalid. Ensure it is a hex-encoded value.',
          invalid_parameters: 'Some request parameters are invalid. Review the highlighted fields.',
          challenge_required: 'Challenge is required for the selected suite.',
          challenge_length: 'Challenge length is invalid for the selected suite.',
          challenge_format: 'Challenge format is invalid for the selected suite.',
          counter_required: 'Counter value is required for the selected suite.',
          counter_negative: 'Counter value cannot be negative.',
          counter_not_permitted: 'Counter is not permitted for the selected suite.',
          session_required: 'Session data is required for the selected suite.',
          session_not_permitted: 'Session data is not permitted for the selected suite.',
          timestamp_drift_exceeded: 'Timestamp exceeded the allowed drift for this suite.',
          timestamp_not_permitted: 'Timestamp is not permitted for the selected suite.',
          timestamp_invalid: 'Timestamp value is invalid. Use a hex-encoded epoch.',
          pin_hash_mismatch: 'PIN hash did not match the stored value.',
          pin_hash_required: 'PIN hash is required for the selected suite.',
          pin_hash_not_permitted: 'PIN hash is not permitted for the selected suite.',
          missing_required: 'A required field is missing for the selected suite.',
        });
        const inlineModeRadio = document.getElementById('mode-inline');
        const suiteInput = document.getElementById('suite');
        const sharedSecretInput = document.getElementById('sharedSecretHex');
        const challengeInput = document.getElementById('challenge');
        const sessionInput = document.getElementById('sessionHex');
        const clientChallengeInput = document.getElementById('clientChallenge');
        const serverChallengeInput = document.getElementById('serverChallenge');
        const pinHashInput = document.getElementById('pinHashHex');
        const timestampInput = document.getElementById('timestampHex');
        const counterInput = document.getElementById('counter');
        const advancedToggle = document.querySelector('[data-testid="ocra-advanced-toggle"]');
        const advancedPanel = document.querySelector('[data-testid="ocra-advanced-panel"]');
        const resultPanel = document.querySelector('[data-testid="ocra-result-panel"]');
        const statusValue = document.querySelector('[data-testid="ocra-status-value"]');
        const otpValue = document.querySelector('[data-testid="ocra-otp-value"]');
        const sanitizedValue = document.querySelector('[data-testid="ocra-sanitized-flag"]');
        const suiteValue = document.querySelector('[data-testid="ocra-suite-value"]');
        const errorPanel = document.querySelector('[data-testid="ocra-error-panel"]');
        const errorPrimary = document.querySelector('[data-testid="ocra-error-primary"]');
        const errorSecondary = document.querySelector('[data-testid="ocra-error-secondary"]');
        const fetchDelegate =
          typeof window.fetch === 'function'
            ? function (endpoint, options) {
                return window.fetch(endpoint, options);
              }
            : function (endpoint, options) {
                return new Promise(function (resolve, reject) {
                  try {
                    var requestOptions = options || {};
                    var xhr = new XMLHttpRequest();
                    var method = requestOptions.method || 'GET';
                    xhr.open(method, endpoint, true);
                    var headers = requestOptions.headers || {};
                    Object.keys(headers).forEach(function (key) {
                      xhr.setRequestHeader(key, headers[key]);
                    });
                    if (
                      requestOptions.credentials &&
                      requestOptions.credentials !== 'omit'
                    ) {
                      xhr.withCredentials = true;
                    }
                    xhr.onload = function () {
                      var responseText = xhr.responseText || '';
                      resolve({
                        ok: xhr.status >= 200 && xhr.status < 300,
                        status: xhr.status,
                        text: function () {
                          return Promise.resolve(responseText);
                        },
                      });
                    };
                    xhr.onerror = function () {
                      reject(new Error('Request failed'));
                    };
                    xhr.send(requestOptions.body || null);
                  } catch (error) {
                    reject(error);
                  }
                });
              };

        function updateSections() {
          const selected = document.querySelector('input[name="mode"]:checked');
          if (!selected) {
            return;
          }
          const inlineActive = selected.value === 'inline';
          sections.forEach(function (section) {
            const active = section.getAttribute('data-mode-section') === selected.value;
            if (active) {
              section.removeAttribute('hidden');
              section.setAttribute('aria-hidden', 'false');
            } else {
              section.setAttribute('hidden', 'hidden');
              section.setAttribute('aria-hidden', 'true');
            }
          });
          inlineRequired.forEach(function (input) {
            if (inlineActive) {
              input.setAttribute('required', 'required');
              input.removeAttribute('disabled');
            } else {
              input.removeAttribute('required');
              input.setAttribute('disabled', 'disabled');
            }
          });
          credentialRequired.forEach(function (input) {
            if (inlineActive) {
              input.removeAttribute('required');
              input.setAttribute('disabled', 'disabled');
            } else {
              input.setAttribute('required', 'required');
              input.removeAttribute('disabled');
            }
          });
        }

        function applyPreset(presetKey) {
          if (!presetKey) {
            return;
          }
          const sample = presetMap[presetKey];
          if (!sample) {
            return;
          }
          if (inlineModeRadio) {
            inlineModeRadio.checked = true;
          }
          updateSections();
          if (suiteInput) {
            suiteInput.value = sample && sample.suite ? sample.suite : '';
          }
          if (sharedSecretInput) {
            sharedSecretInput.value = sample && sample.sharedSecretHex ? sample.sharedSecretHex : '';
          }
          if (challengeInput) {
            challengeInput.value = sample && sample.challenge ? sample.challenge : '';
          }
          if (sessionInput) {
            sessionInput.value = sample && sample.sessionHex ? sample.sessionHex : '';
          }
          if (clientChallengeInput) {
            clientChallengeInput.value = sample && sample.clientChallenge ? sample.clientChallenge : '';
          }
          if (serverChallengeInput) {
            serverChallengeInput.value = sample && sample.serverChallenge ? sample.serverChallenge : '';
          }
          if (pinHashInput) {
            pinHashInput.value = sample && sample.pinHashHex ? sample.pinHashHex : '';
          }
          if (timestampInput) {
            timestampInput.value = sample && sample.timestampHex ? sample.timestampHex : '';
          }
          if (counterInput) {
            counterInput.value = sample && sample.counter != null ? sample.counter : '';
          }
          ensureAdvancedOpenIfNeeded();
        }

        function setTextContent(node, value) {
          if (!node) {
            return;
          }
          node.textContent = value || '';
        }

        function hidePanel(panel) {
          if (!panel) {
            return;
          }
          panel.setAttribute('hidden', 'hidden');
        }

        function showPanel(panel) {
          if (!panel) {
            return;
          }
          panel.removeAttribute('hidden');
        }

        function scrubSecrets() {
          // Shared secret remains visible so operators can reuse verification data.
          if (pinHashInput) {
            pinHashInput.value = '';
          }
        }

        function clearPanels() {
          hidePanel(resultPanel);
          hidePanel(errorPanel);
          setTextContent(statusValue, '');
          setTextContent(otpValue, '');
          setTextContent(sanitizedValue, '');
          setTextContent(suiteValue, '');
          setTextContent(errorPrimary, '');
          setTextContent(errorSecondary, '');
        }

        function toTrimmedValue(input) {
          if (!input || typeof input.value !== 'string') {
            return '';
          }
          return input.value.trim();
        }

        function parseCounter(value) {
          if (!value) {
            return null;
          }
          var parsed = Number(value);
          return Number.isFinite(parsed) ? parsed : null;
        }

        function hasAdvancedValues() {
          return (
            toTrimmedValue(clientChallengeInput)
              || toTrimmedValue(serverChallengeInput)
              || toTrimmedValue(sessionInput)
              || toTrimmedValue(timestampInput)
          );
        }

        function ensureAdvancedOpenIfNeeded() {
          if (!advancedPanel || !advancedToggle) {
            return;
          }
          if (hasAdvancedValues()) {
            setAdvancedState(true);
          }
        }

        function buildPayload() {
          var payload = {};
          var selectedMode = document.querySelector('input[name="mode"]:checked');
          var modeValue = selectedMode ? selectedMode.value : 'inline';
          if (modeValue === 'credential') {
            var credentialValue = toTrimmedValue(document.getElementById('credentialId'));
            if (credentialValue) {
              payload.credentialId = credentialValue;
            }
            var suiteForCredential = toTrimmedValue(suiteInput);
            if (suiteForCredential) {
              payload.suite = suiteForCredential;
            }
          } else {
            var inlineSuite = toTrimmedValue(suiteInput);
            var secretValue = toTrimmedValue(sharedSecretInput);
            if (inlineSuite) {
              payload.suite = inlineSuite;
            }
            if (secretValue) {
              payload.sharedSecretHex = secretValue;
            }
          }

          var challengeValue = toTrimmedValue(challengeInput);
          if (challengeValue) {
            payload.challenge = challengeValue;
          }
          var sessionValue = toTrimmedValue(sessionInput);
          if (sessionValue) {
            payload.sessionHex = sessionValue;
          }
          var clientChallengeValue = toTrimmedValue(clientChallengeInput);
          if (clientChallengeValue) {
            payload.clientChallenge = clientChallengeValue;
          }
          var serverChallengeValue = toTrimmedValue(serverChallengeInput);
          if (serverChallengeValue) {
            payload.serverChallenge = serverChallengeValue;
          }
          var pinHashValue = toTrimmedValue(pinHashInput);
          if (pinHashValue) {
            payload.pinHashHex = pinHashValue;
          }
          var timestampValue = toTrimmedValue(timestampInput);
          if (timestampValue) {
            payload.timestampHex = timestampValue;
          }
          var counterValue = parseCounter(toTrimmedValue(counterInput));
          if (counterValue !== null) {
            payload.counter = counterValue;
          }
          return payload;
        }

        function setBusy(state) {
          if (submitButton) {
            submitButton.disabled = Boolean(state);
          }
          if (form) {
            if (state) {
              form.setAttribute('data-loading', 'true');
            } else {
              form.removeAttribute('data-loading');
            }
          }
        }

        function setAdvancedState(nextState) {
          if (!advancedPanel || !advancedToggle) {
            return;
          }
          advancedPanel.setAttribute('data-open', String(nextState));
          advancedToggle.setAttribute('aria-expanded', String(nextState));
          advancedToggle.setAttribute('data-expanded', String(nextState));
        }

        function toggleAdvanced() {
          if (!advancedPanel || !advancedToggle) {
            return;
          }
          const open = advancedPanel.getAttribute('data-open') === 'true';
          setAdvancedState(!open);
        }

        function renderSuccess(body, payload) {
          const suiteText = body && body.suite ? body.suite : payload.suite || '';
          setTextContent(statusValue, 'Success');
          setTextContent(otpValue, body && body.otp ? body.otp : '');
          const sanitizedFlag =
            body && Object.prototype.hasOwnProperty.call(body, 'sanitized')
              ? String(body.sanitized)
              : 'true';
          setTextContent(sanitizedValue, sanitizedFlag);
          setTextContent(suiteValue, suiteText);
          showPanel(resultPanel);
          hidePanel(errorPanel);
        }

        function deriveErrorMessage(body) {
          const details = body && body.details ? body.details : {};
          const reason = details.reasonCode || ((body && body.error) || 'invalid_input');
          const sanitizedFlag =
            details.sanitized === false || details.sanitized === 'false'
              ? 'false'
              : body && body.sanitized === false
              ? 'false'
              : 'true';
          let primary = (body && body.message) || 'Unable to process your request.';
          if (reason === 'invalid_suite_prefix' && details.prefix) {
            primary = 'Suite prefix ' + details.prefix + ' is not supported.';
          } else if (reason === 'missing_required' && details.field) {
            primary = 'Field "' + details.field + '" is required for the selected suite.';
          } else if (reason === 'invalid_parameters' && details.field) {
            primary = 'Field "' + details.field + '" contains invalid data.';
          } else if (FRIENDLY_ERRORS[reason]) {
            primary = FRIENDLY_ERRORS[reason];
          }
          const secondary =
            sanitizedFlag === 'true'
              ? 'Only sanitized details are shown. Check server logs for additional context.'
              : 'Detailed information is displayed for troubleshooting.';
          return {
            primary: primary,
            secondary: secondary,
          };
        }

        function renderError(body) {
          const derived = deriveErrorMessage(body);
          setTextContent(errorPrimary, derived.primary);
          setTextContent(errorSecondary, derived.secondary);
          hidePanel(resultPanel);
          showPanel(errorPanel);
        }

        function parseJsonSafely(text) {
          if (!text) {
            return null;
          }
          try {
            return JSON.parse(text);
          } catch (err) {
            return null;
          }
        }

        function handleFetch(event) {
          event.preventDefault();
          clearPanels();
          setBusy(true);
          const payload = buildPayload();
          const csrfInput = form ? form.querySelector('input[name="_csrf"]') : null;
          const csrfToken = csrfInput && typeof csrfInput.value === 'string' ? csrfInput.value : '';
          const headers = {
            Accept: 'application/json',
            'Content-Type': 'application/json',
          };
          if (csrfToken) {
            headers['X-CSRF-TOKEN'] = csrfToken;
          }
          fetchDelegate(form.dataset.evaluateEndpoint || '/api/v1/ocra/evaluate', {
              method: 'POST',
              headers: headers,
              body: JSON.stringify(payload),
              credentials: 'same-origin',
            })
            .then(function (response) {
              return response.text().then(function (text) {
                return { ok: response.ok, body: parseJsonSafely(text) };
              });
            })
            .then(function (result) {
              setBusy(false);
              scrubSecrets();
              if (result.ok) {
                renderSuccess(result.body || {}, payload);
                return;
              }
              renderError(result.body);
            })
            .catch(function () {
              setBusy(false);
              scrubSecrets();
              renderError(null);
            });
        }

        modeInputs.forEach(function (input) {
          input.addEventListener('change', updateSections);
        });

        if (policySelect) {
          policySelect.addEventListener('change', function () {
            applyPreset(policySelect.value);
          });
        }

        if (advancedToggle) {
          advancedToggle.addEventListener('click', function () {
            toggleAdvanced();
          });
        }

        [clientChallengeInput, serverChallengeInput, sessionInput, timestampInput].forEach(
          function (input) {
            if (!input) {
              return;
            }
            input.addEventListener('focus', function () {
              setAdvancedState(true);
            });
            input.addEventListener('input', function () {
              ensureAdvancedOpenIfNeeded();
            });
          }
        );

        if (form) {
          form.addEventListener('submit', handleFetch);
          form.addEventListener('keydown', function (event) {
            if (
              event &&
              event.key === 'Enter' &&
              !event.shiftKey &&
              !event.ctrlKey &&
              !event.metaKey &&
              !event.altKey &&
              event.target &&
              event.target.tagName !== 'TEXTAREA' &&
              event.target.tagName !== 'BUTTON'
            ) {
              handleFetch(event);
            }
          });
        }

        if (submitButton) {
          submitButton.addEventListener('click', handleFetch);
        }

        window.__ocraApplyPreset = applyPreset;
        window.__ocraUpdateSections = updateSections;

        updateSections();
        ensureAdvancedOpenIfNeeded();
        if (policySelect && policySelect.value) {
          applyPreset(policySelect.value);
        }
      })();
    </script>
  </body>
</html>
