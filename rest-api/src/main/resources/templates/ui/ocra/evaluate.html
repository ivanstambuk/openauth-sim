<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>OCRA Evaluation</title>
    <link rel="stylesheet" th:href="@{/ui/ocra/console.css}" />
  </head>
  <body>
    <main aria-labelledby="console-heading">
      <h1 id="console-heading">OCRA Evaluation Console</h1>
      <p id="console-summary" class="summary">
        Submit a stored credential or inline secret to evaluate an OCRA response via the REST API.
        Required fields are marked and secrets are never echoed back.
      </p>

      <section
        aria-labelledby="evaluate-heading"
        class="card-shell"
        data-testid="ocra-evaluate-panel"
        th:fragment="ocraEvaluatePanel(visible)"
        th:attr="hidden=${visible == null || visible} ? null : 'hidden', aria-hidden=${visible == null || visible} ? null : 'true'"
      >
        <div class="section-columns">
          <div>
            <h2 id="evaluate-heading" class="section-title">Evaluate an OCRA response</h2>
            <form
                action="#"
                aria-describedby="console-summary"
                data-testid="ocra-evaluate-form"
                class="evaluation-form"
                th:attr="data-evaluate-endpoint=${evaluationEndpoint},data-credentials-endpoint=${credentialsEndpoint},data-seed-endpoint=${seedEndpoint}"
              >
            <input type="hidden" name="_csrf" th:value="${csrfToken}" />

            <fieldset
              data-testid="mode-toggle"
              aria-describedby="mode-help"
              class="mode-toggle"
            >
              <legend>Choose evaluation mode</legend>
              <div class="mode-option">
                <input
                  type="radio"
                  id="mode-inline"
                  name="mode"
                  value="inline"
                  th:checked="${form.mode == 'inline'}"
                />
                <label for="mode-inline">Inline parameters</label>
                <p id="inline-mode-hint" class="hint">
                  Provide the OCRA suite and shared secret manually.
                </p>
              </div>
              <div class="mode-option">
                <input
                  type="radio"
                  id="mode-credential"
                  name="mode"
                  value="credential"
                  th:checked="${form.mode == 'credential'}"
                />
                <label for="mode-credential">Stored credential</label>
                <p id="credential-mode-hint" class="hint">
                  Reference a credential already persisted by the simulator. Secrets remain hidden.
                </p>
              </div>
            </fieldset>

            <div class="seed-actions" data-testid="ocra-seed-actions" hidden="hidden" aria-hidden="true">
              <button
                type="button"
                class="button-secondary"
                data-testid="ocra-seed-credentials"
              >
                Seed sample credentials
              </button>
              <p class="hint" data-testid="ocra-seed-hint">
                Adds canonical demo credentials when the registry is empty or missing presets.
              </p>
              <p
                class="credential-status"
                data-testid="ocra-seed-status"
                aria-live="polite"
                hidden="hidden"
                aria-hidden="true"
              ></p>
            </div>

            <section
              id="inline-parameters"
              data-mode-section="inline"
              th:attr="hidden=${form.mode == 'credential'} ? 'hidden' : null, aria-hidden=${form.mode == 'credential'}"
              class="field-grid"
            >
            <div>
              <label for="policyPreset">Load a sample vector</label>
              <select
                id="policyPreset"
                name="policyPreset"
                th:value="${form.policyPreset}"
                data-testid="inline-policy-select"
              >
                <option value="">Select a sample</option>
                <option
                  th:each="preset : ${policyPresets}"
                  th:value="${preset.key}"
                  th:text="${preset.label}"
                ></option>
              </select>
              <p class="hint">Selecting a preset fills the inline fields with illustrative data.</p>
            </div>

              <div class="policy-builder" data-testid="ocra-policy-builder">
              <h4>Guided policy builder</h4>
              <p class="hint">
                Assemble suite components and apply them to the inline fields. Existing presets remain
                available for quick reference.
              </p>
              <div class="builder-grid">
              <div class="field-group">
                <label for="builderVersion">Version</label>
                <input
                  id="builderVersion"
                  data-testid="ocra-builder-version"
                  type="text"
                  value="OCRA-1"
                  readonly="readonly"
                  aria-readonly="true"
                />
              </div>
                <div class="field-group">
                  <label for="builderAlgorithm">OTP algorithm</label>
                  <select
                    id="builderAlgorithm"
                    class="select-compact"
                    data-testid="ocra-builder-algorithm"
                  >
                    <option value="HOTP-SHA1">HOTP-SHA1</option>
                    <option value="HOTP-SHA256" selected>HOTP-SHA256</option>
                    <option value="HOTP-SHA512">HOTP-SHA512</option>
                  </select>
                </div>
                <div class="field-group">
                  <label for="builderDigits">OTP digits</label>
                  <select
                    id="builderDigits"
                    class="select-compact"
                    data-testid="ocra-builder-digits"
                  >
                    <option value="4">4 digits</option>
                    <option value="6" selected>6 digits</option>
                    <option value="8">8 digits</option>
                    <option value="10">10 digits</option>
                  </select>
                </div>
                <div class="field-group">
                  <label for="builderChallenge">Challenge format</label>
                  <select
                    id="builderChallenge"
                    class="select-compact"
                    data-testid="ocra-builder-challenge"
                  >
                    <option value="QA08" selected>QA08 – alphanumeric (8)</option>
                    <option value="QA10">QA10 – alphanumeric (10)</option>
                    <option value="QA12">QA12 – alphanumeric (12)</option>
                    <option value="QH64">QH64 – hex (64)</option>
                    <option value="QN08">QN08 – numeric (8)</option>
                  </select>
                </div>
                <div class="field-group">
                  <span class="hint">Include data inputs</span>
                  <div
                    class="choice-row choice-grid"
                    data-testid="ocra-builder-data-inputs"
                  >
                    <label
                      for="builderCounter"
                      class="choice-control"
                      data-testid="ocra-builder-counter-label"
                    >
                      <input
                        type="checkbox"
                        id="builderCounter"
                        data-testid="ocra-builder-counter"
                        checked
                      />
                      Counter (C)
                    </label>
                    <label for="builderPin" class="choice-control">
                      <input type="checkbox" id="builderPin" data-testid="ocra-builder-pin" />
                      PIN hash (P)
                    </label>
                    <label for="builderTimestamp" class="choice-control">
                      <input
                        type="checkbox"
                        id="builderTimestamp"
                        data-testid="ocra-builder-timestamp"
                      />
                      Timestamp (T)
                    </label>
                  </div>
                </div>
                <div class="field-group">
                  <label
                    class="choice-label choice-control choice-control--session"
                    for="builderSession"
                  >
                    <input
                      type="checkbox"
                      id="builderSession"
                      data-testid="ocra-builder-session"
                      checked
                    />
                    Session data (S)
                  </label>
                  <label for="builderSessionLength" class="hint">
                    Session length (bits)
                    <input
                      id="builderSessionLength"
                      type="number"
                      min="8"
                      step="8"
                      value="64"
                      data-testid="ocra-builder-session-length"
                    />
                  </label>
                </div>
              </div>

              <div class="builder-secret-hint">
                <span>Generated secret:</span>
                <code data-testid="ocra-builder-secret-preview">—</code>
                <label for="builderSecretLength" class="visually-hidden">Secret length (bytes)</label>
                <select
                  id="builderSecretLength"
                  class="select-compact"
                  data-testid="ocra-builder-secret-length"
                >
                  <option value="20">20 bytes</option>
                  <option value="32" selected>32 bytes</option>
                  <option value="64">64 bytes</option>
                </select>
                <button type="button" class="button-secondary" data-testid="ocra-builder-generate">
                  Generate hex secret
                </button>
              </div>

              <div class="builder-preview">
                <span>Preview:</span>
                <strong data-testid="ocra-builder-preview"></strong>
              </div>

              <p
                class="builder-status"
                data-testid="ocra-builder-status"
                aria-live="polite"
              ></p>

              <div class="builder-actions">
                <button type="button" class="button-primary" data-testid="ocra-builder-apply">
                  Apply configuration
                </button>
                <button type="button" class="button-secondary" data-testid="ocra-builder-reset">
                  Reset builder
                </button>
              </div>
            </div>
              <div>
                <label for="suite">Suite</label>
                <input
                  id="suite"
                  name="suite"
                  type="text"
                  autocomplete="off"
                  th:value="${form.suite}"
                  th:attr="required=${form.inlineMode} ? 'required' : null"
                  data-inline-required="true"
                />
              </div>
              <div>
                <label for="sharedSecretHex">Shared Secret (hex)</label>
                <input
                  id="sharedSecretHex"
                  name="sharedSecretHex"
                  type="text"
                  autocomplete="off"
                  th:value="${form.sharedSecretHex}"
                  placeholder="Hex encoded secret"
                  th:attr="required=${form.inlineMode} ? 'required' : null"
                  data-inline-required="true"
                />
              </div>
              <div>
                <label for="pinHashHex">PIN hash (hex, optional)</label>
                <input
                  id="pinHashHex"
                  name="pinHashHex"
                  type="text"
                  autocomplete="off"
                  th:value="${form.pinHashHex}"
                  placeholder="Optional SHA hash of PIN"
                />
              </div>
            </section>

            <section
              id="credential-parameters"
              data-mode-section="credential"
              th:attr="hidden=${form.mode != 'credential'} ? 'hidden' : null, aria-hidden=${form.mode != 'credential'}"
              class="field-grid"
            >
              <div>
                <label for="credentialId">Stored credential</label>
                <select
                  id="credentialId"
                  name="credentialId"
                  th:value="${form.credentialId}"
                  th:attr="required=${form.credentialMode} ? 'required' : null"
                  data-credential-required="true"
                  data-testid="stored-credential-select"
                >
                  <option value="" selected="selected" disabled="disabled" hidden="hidden">
                    Select a credential
                  </option>
                </select>
                <div class="credential-actions">
                  <button
                    type="button"
                    class="button-secondary"
                    data-testid="stored-credential-autofill"
                  >
                    Auto-fill required parameters
                  </button>
                </div>
                <p
                  class="hint credential-status"
                  data-testid="stored-credential-status"
                  aria-live="polite"
                ></p>
              </div>
            </section>

          <section aria-labelledby="parameters-heading" class="request-parameters">
            <div class="stack-sm">
              <h3 id="parameters-heading">Request parameters</h3>
              <p class="hint" id="parameters-hint">
                Optional fields match the REST API contract. Leave blank to accept backend defaults.
              </p>
              <button
                type="button"
                class="advanced-toggle"
                data-testid="ocra-advanced-toggle"
                aria-controls="advanced-parameters"
                aria-expanded="false"
                data-expanded="false"
              >
                <svg viewBox="0 0 16 16" role="presentation" focusable="false">
                  <path
                    fill="currentColor"
                    d="M8 11a.75.75 0 0 1-.53-.22l-4-4a.75.75 0 1 1 1.06-1.06L8 9.19l3.47-3.47a.75.75 0 0 1 1.06 1.06l-4 4A.75.75 0 0 1 8 11Z"
                  />
                </svg>
                Advanced parameters
              </button>
            </div>

            <div
              id="advanced-parameters"
              class="advanced-panel field-grid"
              data-testid="ocra-advanced-panel"
              data-open="false"
            >
              <div>
                <label for="clientChallenge">Client challenge</label>
                <input
                  id="clientChallenge"
                  name="clientChallenge"
                  type="text"
                  th:value="${form.clientChallenge}"
                  autocomplete="off"
                />
              </div>
              <div>
                <label for="serverChallenge">Server challenge</label>
                <input
                  id="serverChallenge"
                  name="serverChallenge"
                  type="text"
                  th:value="${form.serverChallenge}"
                  autocomplete="off"
                />
              </div>
              <div>
                <label for="sessionHex">Session (hex)</label>
                <textarea
                  id="sessionHex"
                  name="sessionHex"
                  rows="3"
                  th:text="${form.sessionHex}"
                  aria-describedby="parameters-hint"
                ></textarea>
              </div>
              <div>
                <label for="timestampHex">Timestamp (hex)</label>
                <input
                  id="timestampHex"
                  name="timestampHex"
                  type="text"
                  th:value="${form.timestampHex}"
                  autocomplete="off"
                />
              </div>
            </div>

            <div class="field-grid request-primary-grid">
              <div>
                <label for="challenge">Challenge</label>
                <input
                  id="challenge"
                  name="challenge"
                  type="text"
                  th:value="${form.challenge}"
                  autocomplete="off"
                  aria-describedby="parameters-hint"
                />
              </div>
              <div>
                <label for="counter">Counter</label>
                <input
                  id="counter"
                  name="counter"
                  type="number"
                  min="0"
                  th:value="${form.counter}"
                  autocomplete="off"
                />
              </div>
            </div>
          </section>

            <button type="button" class="button-primary" data-testid="ocra-evaluate-button">
              Evaluate response
            </button>
            </form>
          </div>
          <div class="status-column">
            <section
              data-testid="ocra-result-panel"
              aria-live="polite"
              aria-labelledby="result-heading"
              hidden="hidden"
              class="result-panel"
            >
              <h2 id="result-heading">Evaluation result</h2>
              <p data-testid="ocra-otp">
                OTP:
                <strong data-testid="ocra-otp-value"></strong>
              </p>
              <dl data-testid="ocra-telemetry-summary" class="result-metadata">
                <div class="result-row">
                  <dt>Status</dt>
                  <dd data-testid="ocra-status-value"></dd>
                </div>
              </dl>
            </section>

            <section
              data-testid="ocra-error-panel"
              aria-live="assertive"
              role="alert"
              aria-labelledby="error-heading"
              hidden="hidden"
              class="error-panel"
            >
              <div>
                <h2 id="error-heading">Evaluation failed</h2>
                <p data-testid="ocra-error-primary"></p>
                <p class="hint" data-testid="ocra-error-secondary"></p>
              </div>
            </section>
          </div>
        </div>
      </section>
    </main>

    <script
      id="ocra-policy-presets"
      type="application/json"
      th:fragment="ocraPolicyPresetData"
      th:utext="${policyPresetJson}"
    ></script>

    <script
      th:inline="javascript"
      data-testid="ocra-fetch-script"
      th:fragment="ocraEvaluateScripts"
    >
      (function () {
        const modeInputs = document.querySelectorAll('input[name="mode"]');
        const sections = document.querySelectorAll('[data-mode-section]');
        const inlineRequired = document.querySelectorAll('[data-inline-required]');
        const credentialRequired = document.querySelectorAll('[data-credential-required]');
        const policySelect = document.getElementById('policyPreset');
        const inlinePresetElement = document.getElementById('ocra-policy-presets');
        const form = document.querySelector('[data-testid="ocra-evaluate-form"]');
        const submitButton = form
          ? form.querySelector('[data-testid="ocra-evaluate-button"]')
          : null;
        const credentialSelect = document.getElementById('credentialId');
        const credentialStatus = document.querySelector('[data-testid="stored-credential-status"]');
        const credentialsEndpoint = form
          ? form.getAttribute('data-credentials-endpoint')
          : null;
        const autoFillButton = document.querySelector('[data-testid="stored-credential-autofill"]');
        const seedActions = document.querySelector('[data-testid="ocra-seed-actions"]');
        const seedButton = document.querySelector('[data-testid="ocra-seed-credentials"]');
        const seedStatus = document.querySelector('[data-testid="ocra-seed-status"]');
        const seedEndpoint = form ? form.getAttribute('data-seed-endpoint') : null;
        let credentialCache = null;
        let credentialFetchPromise = null;
        let seedInProgress = false;
        let credentialMetadata = Object.create(null);
        const inlinePresets =
          inlinePresetElement && inlinePresetElement.textContent
            ? JSON.parse(inlinePresetElement.textContent)
            : [];
        const presetMap = inlinePresets.reduce(function (acc, preset) {
          if (
            preset &&
            typeof preset.key === 'string' &&
            preset.sample &&
            typeof preset.sample === 'object'
          ) {
            acc[preset.key] = preset.sample;
          }
          return acc;
        }, Object.create(null));
        window.__ocraPresetMap = presetMap;
        const FRIENDLY_ERRORS = Object.freeze({
          credential_not_found: 'Stored credential could not be found. Check the identifier.',
          credential_conflict:
            'Multiple credentials matched this identifier. Use a more specific ID or clean up duplicates.',
          invalid_shared_secret: 'Shared secret is invalid. Ensure it is a hex-encoded value.',
          invalid_parameters: 'Some request parameters are invalid. Review the highlighted fields.',
          challenge_required: 'Challenge is required for the selected suite.',
          challenge_length: 'Challenge length is invalid for the selected suite.',
          challenge_format: 'Challenge format is invalid for the selected suite.',
          counter_required: 'Counter value is required for the selected suite.',
          counter_negative: 'Counter value cannot be negative.',
          counter_not_permitted: 'Counter is not permitted for the selected suite.',
          session_required: 'Session data is required for the selected suite.',
          session_not_permitted: 'Session data is not permitted for the selected suite.',
          timestamp_drift_exceeded: 'Timestamp exceeded the allowed drift for this suite.',
          timestamp_not_permitted: 'Timestamp is not permitted for the selected suite.',
          timestamp_invalid: 'Timestamp value is invalid. Use a hex-encoded epoch.',
          pin_hash_mismatch: 'PIN hash did not match the stored value.',
          pin_hash_required: 'PIN hash is required for the selected suite.',
          pin_hash_not_permitted: 'PIN hash is not permitted for the selected suite.',
          missing_required: 'A required field is missing for the selected suite.',
        });
        const inlineModeRadio = document.getElementById('mode-inline');
        const suiteInput = document.getElementById('suite');
        const sharedSecretInput = document.getElementById('sharedSecretHex');
        const challengeInput = document.getElementById('challenge');
        const sessionInput = document.getElementById('sessionHex');
        const clientChallengeInput = document.getElementById('clientChallenge');
        const serverChallengeInput = document.getElementById('serverChallenge');
        const pinHashInput = document.getElementById('pinHashHex');
        const timestampInput = document.getElementById('timestampHex');
        const counterInput = document.getElementById('counter');
        const advancedToggle = document.querySelector('[data-testid="ocra-advanced-toggle"]');
        const advancedPanel = document.querySelector('[data-testid="ocra-advanced-panel"]');
        const resultPanel = document.querySelector('[data-testid="ocra-result-panel"]');
        const statusValue = document.querySelector('[data-testid="ocra-status-value"]');
        const otpValue = document.querySelector('[data-testid="ocra-otp-value"]');
        const errorPanel = document.querySelector('[data-testid="ocra-error-panel"]');
        const errorPrimary = document.querySelector('[data-testid="ocra-error-primary"]');
        const errorSecondary = document.querySelector('[data-testid="ocra-error-secondary"]');
        const builderVersion = document.getElementById('builderVersion');
        const builderAlgorithm = document.getElementById('builderAlgorithm');
        const builderDigits = document.getElementById('builderDigits');
        const builderChallenge = document.getElementById('builderChallenge');
        const builderCounter = document.getElementById('builderCounter');
        const builderPin = document.getElementById('builderPin');
        const builderTimestamp = document.getElementById('builderTimestamp');
        const builderSession = document.getElementById('builderSession');
        const builderSessionLength = document.getElementById('builderSessionLength');
        const builderPreview = document.querySelector('[data-testid="ocra-builder-preview"]');
        const builderSecretPreview = document.querySelector('[data-testid="ocra-builder-secret-preview"]');
        const builderSecretLength = document.getElementById('builderSecretLength');
        const builderGenerateButton = document.querySelector('[data-testid="ocra-builder-generate"]');
        const builderApplyButton = document.querySelector('[data-testid="ocra-builder-apply"]');
        const builderResetButton = document.querySelector('[data-testid="ocra-builder-reset"]');
        const builderStatus = document.querySelector('[data-testid="ocra-builder-status"]');
        let builderGeneratedSecret = '';
        const fetchDelegate =
          typeof window.fetch === 'function'
            ? function (endpoint, options) {
                return window.fetch(endpoint, options);
              }
            : function (endpoint, options) {
                return new Promise(function (resolve, reject) {
                  try {
                    var requestOptions = options || { };
                    var xhr = new XMLHttpRequest();
                    var method = requestOptions.method || 'GET';
                    xhr.open(method, endpoint, true);
                    var headers = requestOptions.headers || { };
                    Object.keys(headers).forEach(function (key) {
                      xhr.setRequestHeader(key, headers[key]);
                    });
                    if (
                      requestOptions.credentials &&
                      requestOptions.credentials !== 'omit'
                    ) {
                      xhr.withCredentials = true;
                    }
                    xhr.onload = function () {
                      var responseText = xhr.responseText || '';
                      resolve({
                        ok: xhr.status >= 200 && xhr.status < 300,
                        status: xhr.status,
                        text: function () {
                          return Promise.resolve(responseText);
                        },
                      });
                    };
                    xhr.onerror = function () {
                      reject(new Error('Request failed'));
                    };
                    xhr.send(requestOptions.body || null);
                  } catch (error) {
                    reject(error);
                  }
                });
              };

        function updateSections() {
          const selected = document.querySelector('input[name="mode"]:checked');
          if (!selected) {
            return;
          }
          const inlineActive = selected.value === 'inline';
          sections.forEach(function (section) {
            const active = section.getAttribute('data-mode-section') === selected.value;
            if (active) {
              section.removeAttribute('hidden');
              section.setAttribute('aria-hidden', 'false');
            } else {
              section.setAttribute('hidden', 'hidden');
              section.setAttribute('aria-hidden', 'true');
            }
          });
          inlineRequired.forEach(function (input) {
            if (inlineActive) {
              input.setAttribute('required', 'required');
              input.removeAttribute('disabled');
            } else {
              input.removeAttribute('required');
              input.setAttribute('disabled', 'disabled');
            }
          });
          credentialRequired.forEach(function (input) {
            if (inlineActive) {
              input.removeAttribute('required');
              input.setAttribute('disabled', 'disabled');
            } else {
              input.setAttribute('required', 'required');
              input.removeAttribute('disabled');
            }
          });
          if (!inlineActive) {
            ensureCredentialsLoaded().then(function () {
              handleStoredCredentialSelection();
            });
            if (seedActions) {
              seedActions.removeAttribute('hidden');
              seedActions.setAttribute('aria-hidden', 'false');
              if (seedButton && !seedInProgress) {
                seedButton.removeAttribute('disabled');
              }
            }
          } else {
            setCredentialStatus('', false);
            enableAllRequestParameters();
            if (seedActions) {
              seedActions.setAttribute('hidden', 'hidden');
              seedActions.setAttribute('aria-hidden', 'true');
            }
            if (seedButton) {
              seedButton.setAttribute('disabled', 'disabled');
            }
            setSeedStatus('', 'neutral');
          }
        }

        function ensureCredentialsLoaded() {
          if (!credentialSelect || !credentialsEndpoint) {
            return Promise.resolve([]);
          }
          if (credentialCache && credentialCache.length) {
            renderCredentialOptions(credentialCache);
            return Promise.resolve(credentialCache);
          }
          if (credentialFetchPromise) {
            return credentialFetchPromise;
          }
          setCredentialStatus('Loading stored credentials…', false);
          credentialSelect.setAttribute('disabled', 'disabled');
          credentialFetchPromise = fetchDelegate(credentialsEndpoint, {
            method: 'GET',
            headers: { Accept: 'application/json' },
            credentials: 'same-origin',
          })
            .then(function (response) {
              if (!response.ok) {
                throw new Error('Failed to load stored credentials');
              }
              return response.text();
            })
            .then(function (bodyText) {
              var payload = [];
              if (bodyText) {
                try {
                  payload = JSON.parse(bodyText);
                } catch (error) {
                  throw new Error('Invalid credential directory response');
                }
              }
              if (!Array.isArray(payload) && payload && Array.isArray(payload.credentials)) {
                payload = payload.credentials;
              }
              if (!Array.isArray(payload)) {
                payload = [];
              }
              credentialCache = payload
                .map(function (item) {
                  if (!item || typeof item.id !== 'string') {
                    return null;
                  }
                  return {
                    id: item.id,
                    label: typeof item.label === 'string' ? item.label : item.id,
                    suite: typeof item.suite === 'string' ? item.suite : '',
                  };
                })
                .filter(Boolean)
                .sort(function (a, b) {
                  return a.id.localeCompare(b.id, undefined, { sensitivity: 'base' });
                });
              updateCredentialMetadata(credentialCache);
              renderCredentialOptions(credentialCache);
              if (credentialCache.length === 0) {
                setCredentialStatus(
                  'No stored credentials found. Use "Seed sample credentials" or import via the CLI.',
                  false);
              } else {
                setCredentialStatus('', false);
              }
              return credentialCache;
            })
            .catch(function (error) {
              console.error(error);
              credentialCache = [];
              renderCredentialOptions(credentialCache);
              setCredentialStatus('Unable to load stored credentials.', true);
              return [];
            })
            .finally(function () {
              credentialFetchPromise = null;
            });
          return credentialFetchPromise;
        }

        function updateCredentialMetadata(options) {
          credentialMetadata = Object.create(null);
          if (!Array.isArray(options)) {
            return;
          }
          options.forEach(function (option) {
            if (option && typeof option.id === 'string') {
              credentialMetadata[option.id] = option;
            }
          });
        }

        function renderCredentialOptions(options) {
          if (!credentialSelect) {
            return;
          }
          updateCredentialMetadata(options);
          var currentValue = credentialSelect.value;
          var modeNode = document.querySelector('input[name="mode"]:checked');
          var isInline = modeNode ? modeNode.value === 'inline' : true;
          while (credentialSelect.firstChild) {
            credentialSelect.removeChild(credentialSelect.firstChild);
          }
          var placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = options.length
            ? 'Select a credential'
            : 'No stored credentials available';
          placeholder.disabled = options.length > 0;
          placeholder.hidden = options.length > 0;
          placeholder.selected = true;
          credentialSelect.appendChild(placeholder);
          var matched = false;
          options.forEach(function (option) {
            var element = document.createElement('option');
            element.value = option.id;
            element.textContent = option.label;
            if (!matched && option.id === currentValue) {
              element.selected = true;
              matched = true;
            }
            credentialSelect.appendChild(element);
          });
          if (!isInline && options.length > 0) {
            credentialSelect.removeAttribute('disabled');
            if (!matched) {
              credentialSelect.value = '';
            }
          }
          if (options.length === 0) {
            credentialSelect.setAttribute('disabled', 'disabled');
          }
          handleStoredCredentialSelection();
        }

        function setRequestParameterState(input, allowed) {
          if (!input) {
            return;
          }
          if (allowed) {
            input.removeAttribute('disabled');
            return;
          }
          input.setAttribute('disabled', 'disabled');
          if (typeof input.value === 'string') {
            input.value = '';
          }
        }

        function enableAllRequestParameters() {
          [
            challengeInput,
            clientChallengeInput,
            serverChallengeInput,
            counterInput,
            sessionInput,
            timestampInput,
          ].forEach(function (input) {
            if (input) {
              input.removeAttribute('disabled');
            }
          });
          if (!hasAdvancedValues()) {
            setAdvancedState(false);
          }
        }

        function applyRequestParameterConstraints(parsed) {
          if (!parsed) {
            enableAllRequestParameters();
            return;
          }
          var hasChallenge = Boolean(parsed.challenge);
          setRequestParameterState(challengeInput, hasChallenge);
          setRequestParameterState(clientChallengeInput, Boolean(parsed.supportsSplitChallenge));
          setRequestParameterState(serverChallengeInput, Boolean(parsed.supportsSplitChallenge));
          setRequestParameterState(counterInput, Boolean(parsed.counterRequired));
          setRequestParameterState(sessionInput, parsed.sessionLengthBytes > 0);
          setRequestParameterState(timestampInput, Boolean(parsed.timestampRequired));
          if (!parsed.requiresAdvanced && !hasAdvancedValues()) {
            setAdvancedState(false);
          }
        }

        function handleStoredCredentialSelection() {
          if (!credentialSelect) {
            return;
          }
          var selectedId = credentialSelect.value;
          if (!selectedId) {
            enableAllRequestParameters();
            return;
          }
          var metadata = credentialMetadata[selectedId];
          if (!metadata || typeof metadata.suite !== 'string') {
            enableAllRequestParameters();
            return;
          }
          var parsed = parseOcraSuite(metadata.suite);
          if (!parsed) {
            enableAllRequestParameters();
            return;
          }
          applyRequestParameterConstraints(parsed);
        }

        function parseOcraSuite(suite) {
          if (!suite || typeof suite !== 'string') {
            return null;
          }
          var trimmed = suite.trim();
          if (!trimmed) {
            return null;
          }
          var parts = trimmed.split(':');
          if (parts.length !== 3) {
            return null;
          }
          var cryptoPart = parts[1];
          var dataPart = parts[2];
          var result = {
            suite: trimmed,
            counterRequired: false,
            pinRequired: false,
            challenge: null,
            sessionLengthBytes: 0,
            timestampStepSeconds: null,
            timestampRequired: false,
            requiresAdvanced: false,
            supportsSplitChallenge: false,
          };

          var cryptoStep = extractTimeStepSeconds(cryptoPart);
          if (cryptoStep) {
            result.timestampStepSeconds = cryptoStep;
          }

          var tokens = dataPart.split('-');
          tokens.forEach(function (token) {
            var trimmedToken = token.trim();
            if (!trimmedToken) {
              return;
            }
            var upper = trimmedToken.toUpperCase();
            if (upper === 'C') {
              result.counterRequired = true;
              return;
            }
            if (upper.startsWith('Q') && upper.length >= 3) {
              var formatChar = upper.charAt(1);
              var lengthPart = trimmedToken.substring(2).trim();
              var lengthValue = parseInt(lengthPart, 10);
              if (Number.isFinite(lengthValue) && lengthValue > 0) {
                result.challenge = { format: formatChar, length: lengthValue };
              }
              return;
            }
            if (upper.startsWith('P')) {
              result.pinRequired = true;
              return;
            }
            if (upper.startsWith('S')) {
              var sessionToken = trimmedToken.substring(1).trim();
              var sessionLength = parseSessionLength(sessionToken);
              if (Number.isFinite(sessionLength) && sessionLength > 0) {
                result.sessionLengthBytes = sessionLength;
              }
              return;
            }
            if (upper.startsWith('T')) {
              var stepSeconds = parseTimeStepToken(trimmedToken);
              if (Number.isFinite(stepSeconds) && stepSeconds > 0) {
                result.timestampStepSeconds = stepSeconds;
              }
            }
          });

          if (Number.isFinite(result.timestampStepSeconds) && result.timestampStepSeconds > 0) {
            result.timestampRequired = true;
          }
          if (!Number.isFinite(result.sessionLengthBytes) || result.sessionLengthBytes < 0) {
            result.sessionLengthBytes = 0;
          }
          result.requiresAdvanced =
            result.sessionLengthBytes > 0 || result.timestampRequired === true;
          return result;
        }

        function extractTimeStepSeconds(cryptoPart) {
          if (!cryptoPart || typeof cryptoPart !== 'string') {
            return null;
          }
          var cursor = cryptoPart.trim().toUpperCase();
          if (cursor.startsWith('HOTP')) {
            cursor = cursor.substring(4);
            if (cursor.startsWith('-')) {
              cursor = cursor.substring(1);
            }
          }
          if (!cursor.startsWith('T')) {
            return null;
          }
          var idx = 1;
          while (idx < cursor.length && /[0-9]/.test(cursor.charAt(idx))) {
            idx += 1;
          }
          if (idx === 1) {
            return null;
          }
          var numericPart = cursor.substring(1, idx);
          var seconds = parseInt(numericPart, 10);
          if (!Number.isFinite(seconds) || seconds <= 0) {
            return null;
          }
          var unitChar = cursor.charAt(idx);
          if (unitChar === 'M') {
            seconds *= 60;
          } else if (unitChar === 'H') {
            seconds *= 3600;
          }
          return seconds;
        }

        function parseSessionLength(token) {
          if (!token) {
            return 64;
          }
          var trimmed = token.trim();
          if (!trimmed) {
            return 64;
          }
          if (/^[0-9]+$/.test(trimmed)) {
            return parseInt(trimmed, 10);
          }
          var upper = trimmed.toUpperCase();
          if (upper === 'SHA1') {
            return 20;
          }
          if (upper === 'SHA256') {
            return 32;
          }
          if (upper === 'SHA512') {
            return 64;
          }
          return 64;
        }

        function parseTimeStepToken(token) {
          if (!token || typeof token !== 'string') {
            return null;
          }
          var upper = token.trim().toUpperCase();
          if (!upper.startsWith('T')) {
            return null;
          }
          var idx = 1;
          while (idx < upper.length && /[0-9]/.test(upper.charAt(idx))) {
            idx += 1;
          }
          if (idx === 1) {
            return null;
          }
          var numericPart = upper.substring(1, idx);
          var seconds = parseInt(numericPart, 10);
          if (!Number.isFinite(seconds) || seconds <= 0) {
            return null;
          }
          var unitChar = upper.charAt(idx);
          if (unitChar === 'M') {
            seconds *= 60;
          } else if (unitChar === 'H') {
            seconds *= 3600;
          }
          return seconds;
        }

        function randomInt(maxExclusive) {
          if (!Number.isFinite(maxExclusive) || maxExclusive <= 0) {
            return 0;
          }
          if (window.crypto && typeof window.crypto.getRandomValues === 'function') {
            var buffer = new Uint32Array(1);
            window.crypto.getRandomValues(buffer);
            return buffer[0] % maxExclusive;
          }
          return Math.floor(Math.random() * maxExclusive);
        }

        function randomFromAlphabet(length, alphabet) {
          if (!alphabet || alphabet.length === 0) {
            return '';
          }
          var builder = [];
          for (var i = 0; i < length; i += 1) {
            var index = randomInt(alphabet.length);
            builder.push(alphabet.charAt(index));
          }
          return builder.join('');
        }

        function randomDigits(length) {
          return randomFromAlphabet(length, '0123456789');
        }

        function randomAlphanumeric(length) {
          return randomFromAlphabet(length, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');
        }

        function randomAlpha(length) {
          return randomFromAlphabet(length, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
        }

        function randomHexCharacters(length) {
          if (!Number.isFinite(length) || length <= 0) {
            return '';
          }
          var bytesNeeded = Math.ceil(length / 2);
          var hex = generateHex(bytesNeeded);
          if (hex.length > length) {
            hex = hex.substring(0, length);
          }
          return hex;
        }

        function generateChallengeValue(challengeSpec) {
          if (!challengeSpec || !challengeSpec.length) {
            return '';
          }
          var length = challengeSpec.length;
          var format = (challengeSpec.format || '').toUpperCase();
          if (format === 'N') {
            return randomDigits(length);
          }
          if (format === 'H') {
            return randomHexCharacters(length);
          }
          if (format === 'A') {
            return randomAlphanumeric(length);
          }
          return randomAlpha(length);
        }

        function generateCounterValue() {
          var value = randomInt(1000000);
          if (!Number.isFinite(value) || value < 0) {
            value = 0;
          }
          return String(value);
        }

        function computeTimestampHex(stepSeconds) {
          if (!Number.isFinite(stepSeconds) || stepSeconds <= 0) {
            return '';
          }
          var now = Date.now();
          var step = Math.floor(now / (stepSeconds * 1000));
          if (!Number.isFinite(step) || step < 0) {
            step = 0;
          }
          var hex = step.toString(16).toUpperCase();
          if (hex.length % 2 === 1) {
            hex = '0' + hex;
          }
          return hex;
        }

        function autoPopulateForSelectedCredential() {
          if (!credentialSelect) {
            return;
          }
          var credentialId = credentialSelect.value;
          if (!credentialId) {
            setCredentialStatus('Select a stored credential before auto-filling.', true);
            return;
          }
          var metadata = credentialMetadata[credentialId];
          if (!metadata || typeof metadata.suite !== 'string' || !metadata.suite.trim()) {
            setCredentialStatus('Stored credential is missing suite metadata.', true);
            return;
          }
          var parsed = parseOcraSuite(metadata.suite);
          if (!parsed) {
            setCredentialStatus('Unable to derive required parameters for the selected suite.', true);
            return;
          }

          applyRequestParameterConstraints(parsed);
          clearPanels();

          if (suiteInput) {
            suiteInput.value = metadata.suite;
          }

          if (parsed.challenge) {
            challengeInput.value = generateChallengeValue(parsed.challenge);
          } else if (challengeInput) {
            challengeInput.value = '';
          }

          if (parsed.counterRequired) {
            counterInput.value = generateCounterValue();
          } else if (counterInput) {
            counterInput.value = '';
          }

          if (parsed.sessionLengthBytes > 0) {
            sessionInput.value = generateHex(parsed.sessionLengthBytes);
          } else if (sessionInput) {
            sessionInput.value = '';
          }

          if (parsed.timestampRequired) {
            timestampInput.value = computeTimestampHex(parsed.timestampStepSeconds);
          } else if (timestampInput) {
            timestampInput.value = '';
          }

          if (pinHashInput) {
            pinHashInput.value = '';
          }
          if (clientChallengeInput) {
            clientChallengeInput.value = '';
          }
          if (serverChallengeInput) {
            serverChallengeInput.value = '';
          }

          var credentialModeRadio = document.getElementById('mode-credential');
          if (credentialModeRadio) {
            credentialModeRadio.checked = true;
          }
          if (inlineModeRadio) {
            inlineModeRadio.checked = false;
          }
          updateSections();

          if (parsed.requiresAdvanced) {
            setAdvancedState(true);
          } else {
            setAdvancedState(false);
          }
          ensureAdvancedOpenIfNeeded();

          setCredentialStatus('', false);
        }

        function setCredentialStatus(message, isError) {
          if (!credentialStatus) {
            return;
          }
          credentialStatus.textContent = message || '';
          if (isError) {
            credentialStatus.classList.add('credential-status--error');
          } else {
            credentialStatus.classList.remove('credential-status--error');
          }
        }

        function setSeedStatus(message, severity) {
          if (!seedStatus) {
            return;
          }
          const hasMessage = typeof message === 'string' && message.trim().length > 0;
          if (!hasMessage) {
            seedStatus.textContent = '';
            seedStatus.classList.remove('credential-status--error');
            seedStatus.classList.remove('credential-status--warning');
            seedStatus.setAttribute('hidden', 'hidden');
            seedStatus.setAttribute('aria-hidden', 'true');
            return;
          }
          seedStatus.textContent = message;
          seedStatus.classList.remove('credential-status--error');
          seedStatus.classList.remove('credential-status--warning');
          if (severity === 'error') {
            seedStatus.classList.add('credential-status--error');
          } else if (severity === 'warning') {
            seedStatus.classList.add('credential-status--warning');
          }
          seedStatus.removeAttribute('hidden');
          seedStatus.setAttribute('aria-hidden', 'false');
        }

        function applyPreset(presetKey) {
          if (!presetKey) {
            return;
          }
          const sample = presetMap[presetKey];
          if (!sample) {
            return;
          }
          if (inlineModeRadio) {
            inlineModeRadio.checked = true;
          }
          updateSections();
          if (suiteInput) {
            suiteInput.value = sample && sample.suite ? sample.suite : '';
          }
          if (sharedSecretInput) {
            sharedSecretInput.value = sample && sample.sharedSecretHex ? sample.sharedSecretHex : '';
          }
          if (challengeInput) {
            challengeInput.value = sample && sample.challenge ? sample.challenge : '';
          }
          if (sessionInput) {
            sessionInput.value = sample && sample.sessionHex ? sample.sessionHex : '';
          }
          if (clientChallengeInput) {
            clientChallengeInput.value = sample && sample.clientChallenge ? sample.clientChallenge : '';
          }
          if (serverChallengeInput) {
            serverChallengeInput.value = sample && sample.serverChallenge ? sample.serverChallenge : '';
          }
          if (pinHashInput) {
            pinHashInput.value = sample && sample.pinHashHex ? sample.pinHashHex : '';
          }
          if (timestampInput) {
            timestampInput.value = sample && sample.timestampHex ? sample.timestampHex : '';
          }
          if (counterInput) {
            counterInput.value = sample && sample.counter != null ? sample.counter : '';
          }
          ensureAdvancedOpenIfNeeded();
        }

        function setTextContent(node, value) {
          if (!node) {
            return;
          }
          node.textContent = value || '';
        }

        function hidePanel(panel) {
          if (!panel) {
            return;
          }
          panel.setAttribute('hidden', 'hidden');
        }

        function showPanel(panel) {
          if (!panel) {
            return;
          }
          panel.removeAttribute('hidden');
        }

        function scrubSecrets() {
          // Shared secret remains visible so operators can reuse verification data.
          if (pinHashInput) {
            pinHashInput.value = '';
          }
        }

        function clearPanels() {
          hidePanel(resultPanel);
          hidePanel(errorPanel);
          setTextContent(statusValue, '');
          setTextContent(otpValue, '');
          setTextContent(errorPrimary, '');
          setTextContent(errorSecondary, '');
        }

        function toTrimmedValue(input) {
          if (!input || typeof input.value !== 'string') {
            return '';
          }
          return input.value.trim();
        }

        function parseCounter(value) {
          if (!value) {
            return null;
          }
          var parsed = Number(value);
          return Number.isFinite(parsed) ? parsed : null;
        }

        function hasAdvancedValues() {
          return (
            toTrimmedValue(clientChallengeInput)
              || toTrimmedValue(serverChallengeInput)
              || toTrimmedValue(sessionInput)
              || toTrimmedValue(timestampInput)
          );
        }

        function ensureAdvancedOpenIfNeeded() {
          if (!advancedPanel || !advancedToggle) {
            return;
          }
          if (hasAdvancedValues()) {
            setAdvancedState(true);
          }
        }

        function formatSessionLengthBits() {
          if (!(builderSession && builderSession.checked)) {
            return { token: '', warning: null };
          }
          var raw = Number(builderSessionLength ? builderSessionLength.value : 0);
          if (!Number.isFinite(raw) || raw < 8) {
            return { token: '', warning: 'Session length must be at least 8 bits.' };
          }
          if (raw % 8 !== 0) {
            return { token: '', warning: 'Session length must be a multiple of 8 bits.' };
          }
          var formatted = String(raw).padStart(3, '0');
          return { token: 'S' + formatted, warning: null };
        }

        function normalizeDigits(value) {
          var digits = Number(value);
          if (!Number.isFinite(digits)) {
            return { value: '6', warning: 'OTP digits must be numeric.' };
          }
          var allowed = [4, 6, 8, 10];
          if (allowed.indexOf(digits) === -1) {
            return {
              value: String(allowed[1]),
              warning: 'Digits must be one of 4, 6, 8, or 10.',
            };
          }
          return { value: String(digits), warning: null };
        }

        function evaluateBuilderState() {
          var warnings = [];
          var version = builderVersion ? builderVersion.value : 'OCRA-1';
          var algorithm = builderAlgorithm ? builderAlgorithm.value : 'HOTP-SHA1';
          var digitsResult = normalizeDigits(builderDigits ? builderDigits.value : '6');
          if (digitsResult.warning) {
            warnings.push(digitsResult.warning);
          }
          var digits = digitsResult.value;
          var inputs = [];
          if (builderCounter && builderCounter.checked) {
            inputs.push('C');
          }
          if (builderChallenge && builderChallenge.value) {
            inputs.push(builderChallenge.value);
          } else {
            warnings.push('Select a challenge format.');
          }
          if (builderPin && builderPin.checked) {
            inputs.push('P');
          }
          var sessionResult = formatSessionLengthBits();
          if (sessionResult.warning) {
            warnings.push(sessionResult.warning);
          }
          if (sessionResult.token) {
            inputs.push(sessionResult.token);
          }
          if (builderTimestamp && builderTimestamp.checked) {
            inputs.push('T');
          }
          if (!inputs.length) {
            warnings.push('Select at least one data input.');
          }
          var suiteText = inputs.length
            ? version + ':' + algorithm + '-' + digits + ':' + inputs.join('-')
            : '';
          return {
            suite: suiteText,
            warnings: warnings,
          };
        }

        function updateBuilderPreview() {
          if (builderSessionLength) {
            builderSessionLength.disabled = !(builderSession && builderSession.checked);
          }
          var state = evaluateBuilderState();
          if (builderPreview) {
            builderPreview.textContent = state.suite || 'Select options to build a suite';
          }
          if (builderApplyButton) {
            builderApplyButton.disabled = !state.suite || state.warnings.length > 0;
          }
          if (builderStatus) {
            if (state.warnings.length > 0) {
              builderStatus.textContent = state.warnings[0];
              builderStatus.classList.add('builder-status--warning');
            } else {
              builderStatus.textContent = 'Preview updates automatically as you change options.';
              builderStatus.classList.remove('builder-status--warning');
            }
          }
          return state;
        }

        function updateSecretPreview() {
          if (!builderSecretPreview) {
            return;
          }
          builderSecretPreview.textContent = builderGeneratedSecret
            ? builderGeneratedSecret
            : '—';
        }

        function generateHex(lengthBytes) {
          var size = Number(lengthBytes);
          if (!Number.isFinite(size) || size <= 0) {
            size = 32;
          }
          var buffer = new Uint8Array(size);
          if (window.crypto && typeof window.crypto.getRandomValues === 'function') {
            window.crypto.getRandomValues(buffer);
          } else {
            for (var i = 0; i < size; i += 1) {
              buffer[i] = Math.floor(Math.random() * 256);
            }
          }
          var hex = Array.prototype.map
            .call(buffer, function (byte) {
              return byte.toString(16).padStart(2, '0');
            })
            .join('');
          return hex.toUpperCase();
        }

        function applyBuilderSuite() {
          var state = evaluateBuilderState();
          if (!state.suite || state.warnings.length > 0) {
            return;
          }
          if (inlineModeRadio) {
            inlineModeRadio.checked = true;
          }
          updateSections();
          if (suiteInput) {
            suiteInput.value = state.suite;
          }
          if (builderGeneratedSecret && sharedSecretInput) {
            sharedSecretInput.value = builderGeneratedSecret;
          }
        }

        function resetBuilder() {
          if (builderVersion) {
            builderVersion.value = 'OCRA-1';
          }
          if (builderAlgorithm) {
            builderAlgorithm.value = 'HOTP-SHA256';
          }
          if (builderDigits) {
            builderDigits.value = '6';
          }
          if (builderChallenge) {
            builderChallenge.value = 'QA08';
          }
          if (builderCounter) {
            builderCounter.checked = true;
          }
          if (builderPin) {
            builderPin.checked = false;
          }
          if (builderTimestamp) {
            builderTimestamp.checked = false;
          }
          if (builderSession) {
            builderSession.checked = true;
          }
          if (builderSessionLength) {
            builderSessionLength.value = '64';
          }
          builderGeneratedSecret = '';
          updateSecretPreview();
          updateBuilderPreview();
        }

        function buildPayload() {
          var payload = { };
          var selectedMode = document.querySelector('input[name="mode"]:checked');
          var modeValue = selectedMode ? selectedMode.value : 'inline';
          if (modeValue === 'credential') {
            var credentialValue = toTrimmedValue(credentialSelect);
            if (credentialValue) {
              payload.credentialId = credentialValue;
            }
            var suiteForCredential = toTrimmedValue(suiteInput);
            if (suiteForCredential) {
              payload.suite = suiteForCredential;
            }
          } else {
            var inlineSuite = toTrimmedValue(suiteInput);
            var secretValue = toTrimmedValue(sharedSecretInput);
            if (inlineSuite) {
              payload.suite = inlineSuite;
            }
            if (secretValue) {
              payload.sharedSecretHex = secretValue;
            }
          }

          var challengeValue = toTrimmedValue(challengeInput);
          if (challengeValue) {
            payload.challenge = challengeValue;
          }
          var sessionValue = toTrimmedValue(sessionInput);
          if (sessionValue) {
            payload.sessionHex = sessionValue;
          }
          var clientChallengeValue = toTrimmedValue(clientChallengeInput);
          if (clientChallengeValue) {
            payload.clientChallenge = clientChallengeValue;
          }
          var serverChallengeValue = toTrimmedValue(serverChallengeInput);
          if (serverChallengeValue) {
            payload.serverChallenge = serverChallengeValue;
          }
          var pinHashValue = toTrimmedValue(pinHashInput);
          if (pinHashValue) {
            payload.pinHashHex = pinHashValue;
          }
          var timestampValue = toTrimmedValue(timestampInput);
          if (timestampValue) {
            payload.timestampHex = timestampValue;
          }
          var counterValue = parseCounter(toTrimmedValue(counterInput));
          if (counterValue !== null) {
            payload.counter = counterValue;
          }
          return payload;
        }

        function setBusy(state) {
          if (submitButton) {
            submitButton.disabled = Boolean(state);
          }
          if (form) {
            if (state) {
              form.setAttribute('data-loading', 'true');
            } else {
              form.removeAttribute('data-loading');
            }
          }
        }

        function setAdvancedState(nextState) {
          if (!advancedPanel || !advancedToggle) {
            return;
          }
          advancedPanel.setAttribute('data-open', String(nextState));
          advancedToggle.setAttribute('aria-expanded', String(nextState));
          advancedToggle.setAttribute('data-expanded', String(nextState));
        }

        function toggleAdvanced() {
          if (!advancedPanel || !advancedToggle) {
            return;
          }
          const open = advancedPanel.getAttribute('data-open') === 'true';
          setAdvancedState(!open);
        }

        function renderSuccess(body, payload) {
          setTextContent(statusValue, 'Success');
          setTextContent(otpValue, body && body.otp ? body.otp : '');
          showPanel(resultPanel);
          hidePanel(errorPanel);
        }

        function deriveErrorMessage(body) {
          const details = body && body.details ? body.details : { };
          const reason = details.reasonCode || ((body && body.error) || 'invalid_input');
          const sanitizedFlag =
            details.sanitized === false || details.sanitized === 'false'
              ? 'false'
              : body && body.sanitized === false
              ? 'false'
              : 'true';
          let primary = (body && body.message) || 'Unable to process your request.';
          if (reason === 'invalid_suite_prefix' && details.prefix) {
            primary = 'Suite prefix ' + details.prefix + ' is not supported.';
          } else if (reason === 'missing_required' && details.field) {
            primary = 'Field "' + details.field + '" is required for the selected suite.';
          } else if (reason === 'invalid_parameters' && details.field) {
            primary = 'Field "' + details.field + '" contains invalid data.';
          } else if (FRIENDLY_ERRORS[reason]) {
            primary = FRIENDLY_ERRORS[reason];
          }
          const secondary =
            sanitizedFlag === 'true'
              ? 'Only sanitized details are shown. Check server logs for additional context.'
              : 'Detailed information is displayed for troubleshooting.';
          return {
            primary: primary,
            secondary: secondary,
          };
        }

        function renderError(body) {
          const derived = deriveErrorMessage(body);
          setTextContent(errorPrimary, derived.primary);
          setTextContent(errorSecondary, derived.secondary);
          hidePanel(resultPanel);
          showPanel(errorPanel);
        }

        function parseJsonSafely(text) {
          if (!text) {
            return null;
          }
          try {
            return JSON.parse(text);
          } catch (err) {
            return null;
          }
        }

        function handleFetch(event) {
          event.preventDefault();
          clearPanels();
          setBusy(true);
          const payload = buildPayload();
          const csrfInput = form ? form.querySelector('input[name="_csrf"]') : null;
          const csrfToken = csrfInput && typeof csrfInput.value === 'string' ? csrfInput.value : '';
          const headers = {
            Accept: 'application/json',
            'Content-Type': 'application/json',
          };
          if (csrfToken) {
            headers['X-CSRF-TOKEN'] = csrfToken;
          }
          fetchDelegate(form.dataset.evaluateEndpoint || '/api/v1/ocra/evaluate', {
              method: 'POST',
              headers: headers,
              body: JSON.stringify(payload),
              credentials: 'same-origin',
            })
            .then(function (response) {
              return response.text().then(function (text) {
                return { ok: response.ok, body: parseJsonSafely(text) };
              });
            })
            .then(function (result) {
              setBusy(false);
              scrubSecrets();
              if (result.ok) {
                renderSuccess(result.body || { }, payload);
                return;
              }
              renderError(result.body);
            })
            .catch(function () {
              setBusy(false);
              scrubSecrets();
              renderError(null);
            });
        }

        modeInputs.forEach(function (input) {
          input.addEventListener('change', updateSections);
        });

        if (policySelect) {
          policySelect.addEventListener('change', function () {
            applyPreset(policySelect.value);
          });
        }

        if (credentialSelect) {
          credentialSelect.addEventListener('change', handleStoredCredentialSelection);
        }

        if (seedButton) {
          seedButton.addEventListener('click', function () {
            if (seedInProgress) {
              return;
            }
            if (!seedEndpoint) {
              setSeedStatus('Seeding endpoint unavailable.', 'error');
              return;
            }
            seedInProgress = true;
            seedButton.setAttribute('disabled', 'disabled');
            setSeedStatus('Seeding sample credentials…', 'neutral');
            const csrfInput = form ? form.querySelector('input[name="_csrf"]') : null;
            const csrfToken = csrfInput && typeof csrfInput.value === 'string' ? csrfInput.value : '';
            const headers = {
              Accept: 'application/json',
              'Content-Type': 'application/json',
            };
            if (csrfToken) {
              headers['X-CSRF-TOKEN'] = csrfToken;
            }

            fetchDelegate(seedEndpoint, {
              method: 'POST',
              headers: headers,
              credentials: 'same-origin',
            })
              .then(function (response) {
                return response.text().then(function (text) {
                  return { ok: response.ok, body: parseJsonSafely(text) };
                });
              })
              .then(function (result) {
                if (!result.ok) {
                  throw new Error('Seed request failed');
                }
                var addedCount = 0;
                if (result.body) {
                  if (typeof result.body.addedCount === 'number') {
                    addedCount = result.body.addedCount;
                  } else if (Array.isArray(result.body.addedCredentialIds)) {
                    addedCount = result.body.addedCredentialIds.length;
                  }
                }
                var message =
                  'Seeded ' + addedCount + ' sample credential' + (addedCount === 1 ? '' : 's') + '.';
                if (addedCount === 0) {
                  message += ' All sample credentials are already present.';
                }
                setSeedStatus(message, addedCount === 0 ? 'warning' : 'neutral');
                credentialCache = null;
                credentialFetchPromise = null;
                return ensureCredentialsLoaded();
              })
              .catch(function () {
                setSeedStatus('Unable to seed sample credentials.', 'error');
              })
              .finally(function () {
                seedInProgress = false;
                seedButton.removeAttribute('disabled');
              });
          });
        }

        if (advancedToggle) {
          advancedToggle.addEventListener('click', function () {
            toggleAdvanced();
          });
        }

        [clientChallengeInput, serverChallengeInput, sessionInput, timestampInput].forEach(
          function (input) {
            if (!input) {
              return;
            }
            input.addEventListener('focus', function () {
              setAdvancedState(true);
            });
            input.addEventListener('input', function () {
              ensureAdvancedOpenIfNeeded();
            });
          }
        );

        [
          builderVersion,
          builderAlgorithm,
          builderDigits,
          builderChallenge,
          builderCounter,
          builderPin,
          builderTimestamp,
          builderSession,
        ].forEach(function (control) {
          if (!control) {
            return;
          }
          control.addEventListener('change', function () {
            updateBuilderPreview();
          });
        });

        if (builderSessionLength) {
          builderSessionLength.addEventListener('input', function () {
            updateBuilderPreview();
          });
        }

        if (builderGenerateButton) {
          builderGenerateButton.addEventListener('click', function () {
            builderGeneratedSecret = generateHex(
              builderSecretLength ? builderSecretLength.value : 32
            );
            updateSecretPreview();
          });
        }

        if (builderSecretLength) {
          builderSecretLength.addEventListener('change', function () {
            // Do not auto-generate; just update preview hint.
            updateSecretPreview();
          });
        }

        if (builderApplyButton) {
          builderApplyButton.addEventListener('click', function () {
            applyBuilderSuite();
            ensureAdvancedOpenIfNeeded();
          });
        }

        if (builderResetButton) {
          builderResetButton.addEventListener('click', function () {
            resetBuilder();
            ensureAdvancedOpenIfNeeded();
          });
        }

        if (form) {
          form.addEventListener('submit', handleFetch);
          form.addEventListener('keydown', function (event) {
            if (
              event &&
              event.key === 'Enter' &&
              !event.shiftKey &&
              !event.ctrlKey &&
              !event.metaKey &&
              !event.altKey &&
              event.target &&
              event.target.tagName !== 'TEXTAREA' &&
              event.target.tagName !== 'BUTTON'
            ) {
              handleFetch(event);
            }
          });
        }

        if (submitButton) {
          submitButton.addEventListener('click', handleFetch);
        }

        if (autoFillButton) {
          autoFillButton.addEventListener('click', function () {
            ensureCredentialsLoaded()
              .then(function () {
                autoPopulateForSelectedCredential();
              })
              .catch(function () {
                setCredentialStatus('Unable to auto-populate parameters.', true);
              });
          });
        }

        window.__ocraApplyPreset = applyPreset;
        window.__ocraUpdateSections = updateSections;

        updateSections();
        ensureAdvancedOpenIfNeeded();
        resetBuilder();
        updateSecretPreview();
        updateBuilderPreview();
        if (policySelect && policySelect.value) {
          applyPreset(policySelect.value);
        }
      })();
    </script>
  </body>
</html>
