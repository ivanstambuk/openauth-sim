<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>OCRA Evaluation</title>
  </head>
  <body>
    <main aria-labelledby="console-heading">
      <h1 id="console-heading">OCRA Evaluation Console</h1>
      <p id="console-summary">
        Submit a stored credential or inline secret to evaluate an OCRA response via the REST API.
        Required fields are marked and secrets are never echoed back.
      </p>

      <section aria-labelledby="evaluate-heading">
        <h2 id="evaluate-heading">Evaluate an OCRA response</h2>
        <form
          action="#"
          aria-describedby="console-summary"
          data-testid="ocra-evaluate-form"
          th:attr="data-evaluate-endpoint=${evaluationEndpoint}"
        >
          <input type="hidden" name="_csrf" th:value="${csrfToken}" />

          <fieldset data-testid="mode-toggle" aria-describedby="mode-help">
            <legend>Choose evaluation mode</legend>
            <div>
              <input
                type="radio"
                id="mode-inline"
                name="mode"
                value="inline"
                th:checked="${form.mode == 'inline'}"
              />
              <label for="mode-inline">Inline parameters</label>
              <p id="inline-mode-hint" class="hint">
                Provide the OCRA suite and shared secret manually. Use this for quick diagnostics.
              </p>
            </div>
            <div>
              <input
                type="radio"
                id="mode-credential"
                name="mode"
                value="credential"
                th:checked="${form.mode == 'credential'}"
              />
              <label for="mode-credential">Stored credential</label>
              <p id="credential-mode-hint" class="hint">
                Reference a credential already persisted by the simulator. Secrets remain hidden.
              </p>
            </div>
            <p id="mode-help" class="hint">Only one mode can be active for each submission.</p>
          </fieldset>

          <section
            id="inline-parameters"
            data-mode-section="inline"
            th:attr="hidden=${form.mode == 'credential'} ? 'hidden' : null, aria-hidden=${form.mode == 'credential'}"
            aria-labelledby="inline-heading"
          >
            <h3 id="inline-heading">Inline parameters</h3>
            <p class="hint" id="inline-describe">
              Enter the suite and shared secret exactly as hex strings. Secrets remain visible after
              evaluation so operators can reuse verification data; clear the field manually if
              needed.
            </p>
            <div>
              <label for="policyPreset">Load a sample vector</label>
              <select
                id="policyPreset"
                name="policyPreset"
                th:value="${form.policyPreset}"
                data-testid="inline-policy-select"
              >
                <option value="">Select a sample</option>
                <option
                  th:each="preset : ${policyPresets}"
                  th:value="${preset.key}"
                  th:text="${preset.label}"
                ></option>
              </select>
              <p class="hint">Selecting a preset fills the inline fields with illustrative data.</p>
            </div>
            <div>
              <label for="suite">Suite</label>
              <input
                id="suite"
                name="suite"
                type="text"
                autocomplete="off"
                th:value="${form.suite}"
                th:attr="aria-describedby=${'inline-describe'},required=${form.inlineMode} ? 'required' : null"
                data-inline-required="true"
              />
            </div>
            <div>
              <label for="sharedSecretHex">Shared Secret (hex)</label>
              <input
                id="sharedSecretHex"
                name="sharedSecretHex"
                type="text"
                autocomplete="off"
                th:value="${form.sharedSecretHex}"
                placeholder="Hex encoded secret"
                th:attr="aria-describedby=${'inline-describe'},required=${form.inlineMode} ? 'required' : null"
                data-inline-required="true"
              />
            </div>
            <div>
              <label for="pinHashHex">PIN hash (hex, optional)</label>
              <input
                id="pinHashHex"
                name="pinHashHex"
                type="text"
                autocomplete="off"
                th:value="${form.pinHashHex}"
                placeholder="Optional SHA hash of PIN"
              />
            </div>
          </section>

          <section
            id="credential-parameters"
            data-mode-section="credential"
            th:attr="hidden=${form.mode != 'credential'} ? 'hidden' : null, aria-hidden=${form.mode != 'credential'}"
            aria-labelledby="credential-heading"
          >
            <h3 id="credential-heading">Stored credential</h3>
            <p class="hint" id="credential-describe">
              Provide the credential identifier to reuse the stored suite and secret managed by the
              simulator.
            </p>
            <div>
              <label for="credentialId">Credential identifier</label>
              <input
                id="credentialId"
                name="credentialId"
                type="text"
                autocomplete="off"
                th:value="${form.credentialId}"
                aria-describedby="credential-describe"
                th:attr="required=${form.credentialMode} ? 'required' : null"
                data-credential-required="true"
              />
            </div>
          </section>

          <section aria-labelledby="parameters-heading" class="request-parameters">
            <h3 id="parameters-heading">Request parameters</h3>
            <p class="hint" id="parameters-hint">
              Optional fields match the REST API contract. Leave blank to accept backend defaults.
            </p>
            <div>
              <label for="challenge">Challenge</label>
              <input
                id="challenge"
                name="challenge"
                type="text"
                th:value="${form.challenge}"
                autocomplete="off"
                aria-describedby="parameters-hint"
              />
            </div>
            <div>
              <label for="clientChallenge">Client challenge</label>
              <input
                id="clientChallenge"
                name="clientChallenge"
                type="text"
                th:value="${form.clientChallenge}"
                autocomplete="off"
              />
            </div>
            <div>
              <label for="serverChallenge">Server challenge</label>
              <input
                id="serverChallenge"
                name="serverChallenge"
                type="text"
                th:value="${form.serverChallenge}"
                autocomplete="off"
              />
            </div>
            <div>
              <label for="sessionHex">Session (hex)</label>
              <textarea
                id="sessionHex"
                name="sessionHex"
                rows="3"
                th:text="${form.sessionHex}"
                aria-describedby="parameters-hint"
              ></textarea>
            </div>
            <div>
              <label for="timestampHex">Timestamp (hex)</label>
              <input
                id="timestampHex"
                name="timestampHex"
                type="text"
                th:value="${form.timestampHex}"
                autocomplete="off"
              />
            </div>
            <div>
              <label for="counter">Counter</label>
              <input
                id="counter"
                name="counter"
                type="number"
                min="0"
                th:value="${form.counter}"
                autocomplete="off"
              />
            </div>
          </section>

          <button type="button" data-testid="ocra-evaluate-button">Evaluate</button>
        </form>
      </section>

      <section
        data-testid="ocra-result-panel"
        aria-live="polite"
        aria-labelledby="result-heading"
        hidden="hidden"
      >
        <h2 id="result-heading">Evaluation result</h2>
        <p data-testid="ocra-otp">
          OTP:
          <strong data-testid="ocra-otp-value"></strong>
        </p>
        <p id="telemetry-instructions" class="hint">
          Copy the telemetry summary when escalating issues; it contains only sanitized values.
        </p>
        <dl data-testid="ocra-telemetry-summary" aria-describedby="telemetry-instructions">
          <dt>Status</dt>
          <dd data-testid="ocra-status-value"></dd>
          <dt>Telemetry ID</dt>
          <dd data-testid="ocra-telemetry-id"></dd>
          <dt>Reason code</dt>
          <dd data-testid="ocra-reason-code"></dd>
          <dt>Sanitized</dt>
          <dd data-testid="ocra-sanitized-flag"></dd>
          <dt>Suite</dt>
          <dd data-testid="ocra-suite-value"></dd>
        </dl>
      </section>

      <section
        data-testid="ocra-error-panel"
        aria-live="assertive"
        role="alert"
        aria-labelledby="error-heading"
        hidden="hidden"
      >
        <div>
          <h2 id="error-heading">Evaluation failed</h2>
          <p data-testid="ocra-error-reason"></p>
          <p data-testid="ocra-error-sanitized"></p>
          <p data-testid="ocra-error-message"></p>
        </div>
      </section>
    </main>

    <script
      id="ocra-policy-presets"
      type="application/json"
      th:utext="${policyPresetJson}"
    ></script>

    <script th:inline="javascript" data-testid="ocra-fetch-script">
      (function () {
        const modeInputs = document.querySelectorAll('input[name="mode"]');
        const sections = document.querySelectorAll('[data-mode-section]');
        const inlineRequired = document.querySelectorAll('[data-inline-required]');
        const credentialRequired = document.querySelectorAll('[data-credential-required]');
        const policySelect = document.getElementById('policyPreset');
        const inlinePresetElement = document.getElementById('ocra-policy-presets');
        const form = document.querySelector('[data-testid="ocra-evaluate-form"]');
        const submitButton = form
          ? form.querySelector('[data-testid="ocra-evaluate-button"]')
          : null;
        const inlinePresets =
          inlinePresetElement && inlinePresetElement.textContent
            ? JSON.parse(inlinePresetElement.textContent)
            : [];
        const presetMap = inlinePresets.reduce(function (acc, preset) {
          if (
            preset &&
            typeof preset.key === 'string' &&
            preset.sample &&
            typeof preset.sample === 'object'
          ) {
            acc[preset.key] = preset.sample;
          }
          return acc;
        }, Object.create(null));
        window.__ocraPresetMap = presetMap;
        const inlineModeRadio = document.getElementById('mode-inline');
        const suiteInput = document.getElementById('suite');
        const sharedSecretInput = document.getElementById('sharedSecretHex');
        const challengeInput = document.getElementById('challenge');
        const sessionInput = document.getElementById('sessionHex');
        const clientChallengeInput = document.getElementById('clientChallenge');
        const serverChallengeInput = document.getElementById('serverChallenge');
        const pinHashInput = document.getElementById('pinHashHex');
        const timestampInput = document.getElementById('timestampHex');
        const counterInput = document.getElementById('counter');
        const resultPanel = document.querySelector('[data-testid="ocra-result-panel"]');
        const statusValue = document.querySelector('[data-testid="ocra-status-value"]');
        const otpValue = document.querySelector('[data-testid="ocra-otp-value"]');
        const telemetryValue = document.querySelector('[data-testid="ocra-telemetry-id"]');
        const reasonValue = document.querySelector('[data-testid="ocra-reason-code"]');
        const sanitizedValue = document.querySelector('[data-testid="ocra-sanitized-flag"]');
        const suiteValue = document.querySelector('[data-testid="ocra-suite-value"]');
        const errorPanel = document.querySelector('[data-testid="ocra-error-panel"]');
        const errorReason = document.querySelector('[data-testid="ocra-error-reason"]');
        const errorSanitized = document.querySelector('[data-testid="ocra-error-sanitized"]');
        const errorMessage = document.querySelector('[data-testid="ocra-error-message"]');
        const fetchDelegate =
          typeof window.fetch === 'function'
            ? function (endpoint, options) {
                return window.fetch(endpoint, options);
              }
            : function (endpoint, options) {
                return new Promise(function (resolve, reject) {
                  try {
                    var requestOptions = options || {};
                    var xhr = new XMLHttpRequest();
                    var method = requestOptions.method || 'GET';
                    xhr.open(method, endpoint, true);
                    var headers = requestOptions.headers || {};
                    Object.keys(headers).forEach(function (key) {
                      xhr.setRequestHeader(key, headers[key]);
                    });
                    if (
                      requestOptions.credentials &&
                      requestOptions.credentials !== 'omit'
                    ) {
                      xhr.withCredentials = true;
                    }
                    xhr.onload = function () {
                      var responseText = xhr.responseText || '';
                      resolve({
                        ok: xhr.status >= 200 && xhr.status < 300,
                        status: xhr.status,
                        text: function () {
                          return Promise.resolve(responseText);
                        },
                      });
                    };
                    xhr.onerror = function () {
                      reject(new Error('Request failed'));
                    };
                    xhr.send(requestOptions.body || null);
                  } catch (error) {
                    reject(error);
                  }
                });
              };

        function updateSections() {
          const selected = document.querySelector('input[name="mode"]:checked');
          if (!selected) {
            return;
          }
          const inlineActive = selected.value === 'inline';
          sections.forEach(function (section) {
            const active = section.getAttribute('data-mode-section') === selected.value;
            if (active) {
              section.removeAttribute('hidden');
              section.setAttribute('aria-hidden', 'false');
            } else {
              section.setAttribute('hidden', 'hidden');
              section.setAttribute('aria-hidden', 'true');
            }
          });
          inlineRequired.forEach(function (input) {
            if (inlineActive) {
              input.setAttribute('required', 'required');
              input.removeAttribute('disabled');
            } else {
              input.removeAttribute('required');
              input.setAttribute('disabled', 'disabled');
            }
          });
          credentialRequired.forEach(function (input) {
            if (inlineActive) {
              input.removeAttribute('required');
              input.setAttribute('disabled', 'disabled');
            } else {
              input.setAttribute('required', 'required');
              input.removeAttribute('disabled');
            }
          });
        }

        function applyPreset(presetKey) {
          if (!presetKey) {
            return;
          }
          const sample = presetMap[presetKey];
          if (!sample) {
            return;
          }
          if (inlineModeRadio) {
            inlineModeRadio.checked = true;
          }
          updateSections();
          if (suiteInput) {
            suiteInput.value = sample && sample.suite ? sample.suite : '';
          }
          if (sharedSecretInput) {
            sharedSecretInput.value = sample && sample.sharedSecretHex ? sample.sharedSecretHex : '';
          }
          if (challengeInput) {
            challengeInput.value = sample && sample.challenge ? sample.challenge : '';
          }
          if (sessionInput) {
            sessionInput.value = sample && sample.sessionHex ? sample.sessionHex : '';
          }
          if (clientChallengeInput) {
            clientChallengeInput.value = sample && sample.clientChallenge ? sample.clientChallenge : '';
          }
          if (serverChallengeInput) {
            serverChallengeInput.value = sample && sample.serverChallenge ? sample.serverChallenge : '';
          }
          if (pinHashInput) {
            pinHashInput.value = sample && sample.pinHashHex ? sample.pinHashHex : '';
          }
          if (timestampInput) {
            timestampInput.value = sample && sample.timestampHex ? sample.timestampHex : '';
          }
          if (counterInput) {
            counterInput.value = sample && sample.counter != null ? sample.counter : '';
          }
        }

        function setTextContent(node, value) {
          if (!node) {
            return;
          }
          node.textContent = value || '';
        }

        function hidePanel(panel) {
          if (!panel) {
            return;
          }
          panel.setAttribute('hidden', 'hidden');
        }

        function showPanel(panel) {
          if (!panel) {
            return;
          }
          panel.removeAttribute('hidden');
        }

        function scrubSecrets() {
          // Shared secret remains visible so operators can reuse verification data.
          if (pinHashInput) {
            pinHashInput.value = '';
          }
        }

        function clearPanels() {
          hidePanel(resultPanel);
          hidePanel(errorPanel);
          setTextContent(statusValue, '');
          setTextContent(otpValue, '');
          setTextContent(telemetryValue, '');
          setTextContent(reasonValue, '');
          setTextContent(sanitizedValue, '');
          setTextContent(suiteValue, '');
          setTextContent(errorReason, '');
          setTextContent(errorSanitized, '');
          setTextContent(errorMessage, '');
        }

        function toTrimmedValue(input) {
          if (!input || typeof input.value !== 'string') {
            return '';
          }
          return input.value.trim();
        }

        function parseCounter(value) {
          if (!value) {
            return null;
          }
          var parsed = Number(value);
          return Number.isFinite(parsed) ? parsed : null;
        }

        function buildPayload() {
          var payload = {};
          var selectedMode = document.querySelector('input[name="mode"]:checked');
          var modeValue = selectedMode ? selectedMode.value : 'inline';
          if (modeValue === 'credential') {
            var credentialValue = toTrimmedValue(document.getElementById('credentialId'));
            if (credentialValue) {
              payload.credentialId = credentialValue;
            }
            var suiteForCredential = toTrimmedValue(suiteInput);
            if (suiteForCredential) {
              payload.suite = suiteForCredential;
            }
          } else {
            var inlineSuite = toTrimmedValue(suiteInput);
            var secretValue = toTrimmedValue(sharedSecretInput);
            if (inlineSuite) {
              payload.suite = inlineSuite;
            }
            if (secretValue) {
              payload.sharedSecretHex = secretValue;
            }
          }

          var challengeValue = toTrimmedValue(challengeInput);
          if (challengeValue) {
            payload.challenge = challengeValue;
          }
          var sessionValue = toTrimmedValue(sessionInput);
          if (sessionValue) {
            payload.sessionHex = sessionValue;
          }
          var clientChallengeValue = toTrimmedValue(clientChallengeInput);
          if (clientChallengeValue) {
            payload.clientChallenge = clientChallengeValue;
          }
          var serverChallengeValue = toTrimmedValue(serverChallengeInput);
          if (serverChallengeValue) {
            payload.serverChallenge = serverChallengeValue;
          }
          var pinHashValue = toTrimmedValue(pinHashInput);
          if (pinHashValue) {
            payload.pinHashHex = pinHashValue;
          }
          var timestampValue = toTrimmedValue(timestampInput);
          if (timestampValue) {
            payload.timestampHex = timestampValue;
          }
          var counterValue = parseCounter(toTrimmedValue(counterInput));
          if (counterValue !== null) {
            payload.counter = counterValue;
          }
          return payload;
        }

        function setBusy(state) {
          if (submitButton) {
            submitButton.disabled = Boolean(state);
          }
          if (form) {
            if (state) {
              form.setAttribute('data-loading', 'true');
            } else {
              form.removeAttribute('data-loading');
            }
          }
        }

        function renderSuccess(body, payload) {
          const suiteText = body && body.suite ? body.suite : payload.suite || '';
          setTextContent(statusValue, 'success');
          setTextContent(otpValue, body && body.otp ? body.otp : '');
          setTextContent(telemetryValue, body && body.telemetryId ? body.telemetryId : '');
          setTextContent(reasonValue, 'success');
          setTextContent(sanitizedValue, 'true');
          setTextContent(suiteValue, suiteText);
          showPanel(resultPanel);
          hidePanel(errorPanel);
        }

        function renderError(body) {
          const details = body && body.details ? body.details : {};
          const reason = details.reasonCode || (body && body.error) || 'invalid_input';
          const sanitized = details.sanitized || 'true';
          const message = (body && body.message) || 'Your request could not be processed';
          setTextContent(errorReason, reason);
          setTextContent(errorSanitized, sanitized);
          setTextContent(errorMessage, message);
          hidePanel(resultPanel);
          showPanel(errorPanel);
        }

        function parseJsonSafely(text) {
          if (!text) {
            return null;
          }
          try {
            return JSON.parse(text);
          } catch (err) {
            return null;
          }
        }

        function handleFetch(event) {
          event.preventDefault();
          clearPanels();
          setBusy(true);
          const payload = buildPayload();
          const csrfInput = form ? form.querySelector('input[name="_csrf"]') : null;
          const csrfToken = csrfInput && typeof csrfInput.value === 'string' ? csrfInput.value : '';
          const headers = {
            Accept: 'application/json',
            'Content-Type': 'application/json',
          };
          if (csrfToken) {
            headers['X-CSRF-TOKEN'] = csrfToken;
          }
          fetchDelegate(form.dataset.evaluateEndpoint || '/api/v1/ocra/evaluate', {
              method: 'POST',
              headers: headers,
              body: JSON.stringify(payload),
              credentials: 'same-origin',
            })
            .then(function (response) {
              return response.text().then(function (text) {
                return { ok: response.ok, body: parseJsonSafely(text) };
              });
            })
            .then(function (result) {
              setBusy(false);
              scrubSecrets();
              if (result.ok) {
                renderSuccess(result.body || {}, payload);
                return;
              }
              renderError(result.body);
            })
            .catch(function () {
              setBusy(false);
              scrubSecrets();
              renderError(null);
            });
        }

        modeInputs.forEach(function (input) {
          input.addEventListener('change', updateSections);
        });

        if (policySelect) {
          policySelect.addEventListener('change', function () {
            applyPreset(policySelect.value);
          });
        }

        if (form) {
          form.addEventListener('submit', handleFetch);
          form.addEventListener('keydown', function (event) {
            if (
              event &&
              event.key === 'Enter' &&
              !event.shiftKey &&
              !event.ctrlKey &&
              !event.metaKey &&
              !event.altKey &&
              event.target &&
              event.target.tagName !== 'TEXTAREA' &&
              event.target.tagName !== 'BUTTON'
            ) {
              handleFetch(event);
            }
          });
        }

        if (submitButton) {
          submitButton.addEventListener('click', handleFetch);
        }

        window.__ocraApplyPreset = applyPreset;
        window.__ocraUpdateSections = updateSections;

        updateSections();
        if (policySelect && policySelect.value) {
          applyPreset(policySelect.value);
        }
      })();
    </script>
  </body>
</html>
