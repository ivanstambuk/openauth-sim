<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Operator Console</title>
    <link rel="stylesheet" th:href="@{/ui/console/console.css}" />
    <link rel="stylesheet" th:href="@{/ui/protocol-info.css}" />
  </head>
  <body>
    <main
        class="operator-console"
        aria-labelledby="operator-console-heading"
        th:attr="data-active-protocol=${activeProtocol}">
      <header class="console-header">
        <div class="console-header__title">
          <h1 id="operator-console-heading">Operator Console</h1>
        </div>
        <div
            class="protocol-tabs"
            data-testid="operator-protocol-tabs"
            role="tablist"
            aria-label="Operator protocol selector"
          >
            <button
                th:class="'protocol-tab' + (${activeProtocol}=='hotp' ? ' protocol-tab--active' : '')"
                data-testid="protocol-tab-hotp"
                data-protocol-tab="hotp"
                role="tab"
                th:attr="aria-selected=${activeProtocol}=='hotp' ? 'true' : 'false', aria-controls='protocol-panel-hotp'"
              >
              HOTP
            </button>
            <button
                th:class="'protocol-tab' + (${activeProtocol}=='totp' ? ' protocol-tab--active' : '')"
                data-testid="protocol-tab-totp"
                data-protocol-tab="totp"
                role="tab"
                th:attr="aria-selected=${activeProtocol}=='totp' ? 'true' : 'false', aria-controls='protocol-panel-totp'"
              >
              TOTP
            </button>
            <button
                th:class="'protocol-tab' + (${activeProtocol}=='ocra' ? ' protocol-tab--active' : '')"
                data-testid="protocol-tab-ocra"
                data-protocol-tab="ocra"
                role="tab"
                th:attr="aria-selected=${activeProtocol}=='ocra' ? 'true' : 'false', aria-controls='protocol-panel-ocra'"
              >
              OCRA
            </button>
            <button
                th:class="'protocol-tab' + (${activeProtocol}=='emv' ? ' protocol-tab--active' : '')"
                data-testid="protocol-tab-emv"
                role="tab"
                data-protocol-tab="emv"
                th:attr="aria-selected=${activeProtocol}=='emv' ? 'true' : 'false', aria-controls='protocol-panel-emv'"
              >
              EMV / CAP
            </button>
            <button
                th:class="'protocol-tab' + (${activeProtocol}=='fido2' ? ' protocol-tab--active' : '')"
                data-testid="protocol-tab-fido2"
                role="tab"
                data-protocol-tab="fido2"
                th:attr="aria-selected=${activeProtocol}=='fido2' ? 'true' : 'false', aria-controls='protocol-panel-fido2'"
              >
              FIDO2 / WebAuthn
            </button>
            <button
                th:class="'protocol-tab' + (${activeProtocol}=='eudi-openid4vp' ? ' protocol-tab--active' : '')"
                data-testid="protocol-tab-eudi-openid4vp"
                data-protocol-tab="eudi-openid4vp"
                role="tab"
                th:attr="aria-selected=${activeProtocol}=='eudi-openid4vp' ? 'true' : 'false', aria-controls='protocol-panel-eudi-openid4vp'"
              >
              EUDIW OpenID4VP 1.0
            </button>
            <button
                th:class="'protocol-tab' + (${activeProtocol}=='eudi-iso-18013-5' ? ' protocol-tab--active' : '')"
                data-testid="protocol-tab-eudi-iso-18013-5"
                data-protocol-tab="eudi-iso-18013-5"
                role="tab"
                th:attr="aria-selected=${activeProtocol}=='eudi-iso-18013-5' ? 'true' : 'false', aria-controls='protocol-panel-eudi-iso-18013-5'"
              >
              EUDIW ISO/IEC 18013-5
            </button>
            <button
                th:class="'protocol-tab' + (${activeProtocol}=='eudi-siopv2' ? ' protocol-tab--active' : '')"
                data-testid="protocol-tab-eudi-siopv2"
                data-protocol-tab="eudi-siopv2"
                role="tab"
                th:attr="aria-selected=${activeProtocol}=='eudi-siopv2' ? 'true' : 'false', aria-controls='protocol-panel-eudi-siopv2'"
              >
              EUDIW SIOPv2
            </button>
            <button
                type="button"
                class="protocol-info-trigger"
                data-testid="protocol-info-trigger"
                th:attr="data-protocol=${activeProtocol}"
                aria-label="Protocol info"
                aria-haspopup="dialog"
                aria-controls="protocol-info-surface"
                aria-expanded="false"
              >
              <span aria-hidden="true">i</span>
            </button>
          </div>
      </header>

      <section
          id="protocol-panel-ocra"
          class="protocol-panel"
          data-protocol-panel="ocra"
          aria-labelledby="protocol-tab-ocra"
          th:attr="hidden=${activeProtocol}!='ocra' ? 'hidden' : null, aria-hidden=${activeProtocol}!='ocra' ? 'true' : null"
        >
        <div
            class="ocra-mode-toggle"
            data-testid="ocra-mode-toggle"
            data-mode="evaluate"
            role="tablist"
            aria-label="OCRA interaction modes"
            th:attr="hidden=${activeProtocol}!='ocra' ? 'hidden' : null, aria-hidden=${activeProtocol}!='ocra' ? 'true' : null"
          >
          <button
              type="button"
              class="mode-pill mode-pill--active"
              data-testid="ocra-mode-select-evaluate"
              role="tab"
              aria-selected="true"
            >
            Evaluate
          </button>
          <button
              type="button"
              class="mode-pill"
              data-testid="ocra-mode-select-replay"
              role="tab"
              aria-selected="false"
            >
            Replay
          </button>
        </div>

        <th:block th:replace="~{ui/ocra/evaluate :: ocraEvaluatePanel(visible=${true})}"></th:block>
        <th:block th:replace="~{ui/ocra/evaluate :: ocraPolicyPresetData}"></th:block>

        <th:block th:replace="~{ui/ocra/replay :: ocraReplayPanel(visible=${false})}"></th:block>
        <th:block th:replace="~{ui/ocra/replay :: ocraReplayPresetData}"></th:block>
      </section>
      <th:block th:replace="~{ui/hotp/panel :: hotpPanel(${activeProtocol}=='hotp')}"></th:block>

      <th:block th:replace="~{ui/totp/panel :: totpPanel(${activeProtocol}=='totp')}"></th:block>
      <th:block th:replace="~{ui/fido2/panel :: fido2Panel(${activeProtocol}=='fido2')}"></th:block>

      <section
          class="verbose-trace-controls"
          data-testid="verbose-trace-controls"
        >
        <label class="verbose-trace-toggle" data-testid="verbose-trace-toggle">
          <input type="checkbox" data-testid="verbose-trace-checkbox" />
          <span>Enable verbose tracing for the next request</span>
        </label>
        <p class="verbose-trace-hint">
          Verbose traces expose raw secrets and intermediate buffers. Use only in trusted environments.
        </p>
      </section>

      <section
          class="verbose-trace-panel"
          data-testid="verbose-trace-panel"
          data-trace-visible="false"
          data-trace-variant="info"
          hidden="hidden"
        >
        <header class="verbose-trace-panel__header">
          <h2 class="verbose-trace-panel__title">Verbose trace</h2>
          <div class="verbose-trace-panel__actions">
            <button
                type="button"
                class="verbose-trace-button"
                data-testid="verbose-trace-copy"
                aria-label="Copy verbose trace to clipboard"
              >
              Copy trace
            </button>
          </div>
        </header>
        <p class="verbose-trace-panel__operation">
          Operation:
          <span data-testid="verbose-trace-operation">—</span>
        </p>
        <details class="verbose-trace-panel__details" data-testid="verbose-trace-details">
          <summary class="verbose-trace-panel__summary" data-testid="verbose-trace-summary">
            Trace steps
          </summary>
          <pre class="verbose-trace-panel__content" data-testid="verbose-trace-content"></pre>
        </details>
      </section>

      <section
          id="protocol-panel-emv"
          class="protocol-panel protocol-panel--placeholder"
          data-protocol-panel="emv"
          aria-labelledby="protocol-tab-emv"
          th:attr="hidden=${activeProtocol}!='emv' ? 'hidden' : null, aria-hidden=${activeProtocol}!='emv' ? 'true' : null"
        >
        <h2>EMV / CAP</h2>
        <p>
          EMV/CAP operator workflows are planned. This panel will light up when credential flows and UI
          scaffolding are available.
        </p>
      </section>

      <section
          id="protocol-panel-eudi-openid4vp"
          class="protocol-panel protocol-panel--placeholder"
          data-protocol-panel="eudi-openid4vp"
          aria-labelledby="protocol-tab-eudi-openid4vp"
          th:attr="hidden=${activeProtocol}!='eudi-openid4vp' ? 'hidden' : null, aria-hidden=${activeProtocol}!='eudi-openid4vp' ? 'true' : null"
        >
        <h2>EUDIW OpenID4VP 1.0</h2>
        <p>
          EUDI wallet OpenID4VP 1.0 presentation tooling will land in a dedicated workstream. Placeholder
          remains until the simulator can orchestrate credential offers and verifications.
        </p>
      </section>

      <section
          id="protocol-panel-eudi-iso-18013-5"
          class="protocol-panel protocol-panel--placeholder"
          data-protocol-panel="eudi-iso-18013-5"
          aria-labelledby="protocol-tab-eudi-iso-18013-5"
          th:attr="hidden=${activeProtocol}!='eudi-iso-18013-5' ? 'hidden' : null, aria-hidden=${activeProtocol}!='eudi-iso-18013-5' ? 'true' : null"
        >
        <h2>EUDIW ISO/IEC 18013-5</h2>
        <p>
          ISO/IEC 18013-5 mobile driving licence flows will surface here once credential issuance and
          presentation pipelines are implemented.
        </p>
      </section>

      <section
          id="protocol-panel-eudi-siopv2"
          class="protocol-panel protocol-panel--placeholder"
          data-protocol-panel="eudi-siopv2"
          aria-labelledby="protocol-tab-eudi-siopv2"
          th:attr="hidden=${activeProtocol}!='eudi-siopv2' ? 'hidden' : null, aria-hidden=${activeProtocol}!='eudi-siopv2' ? 'true' : null"
        >
        <h2>EUDIW SIOPv2</h2>
        <p>
          SIOPv2 authentication journeys for the EUDI wallet will appear here when the simulator supports
          self-issued OpenID provider interactions.
        </p>
      </section>

      <div
          class="protocol-info-backdrop"
          data-testid="protocol-info-backdrop"
          data-mode="drawer"
          data-visible="false"
          hidden="hidden"
        ></div>
      <aside
          id="protocol-info-surface"
          class="protocol-info-surface"
          data-testid="protocol-info-surface"
          data-open="false"
          data-surface-mode="drawer"
          data-active-protocol="ocra"
          role="complementary"
          aria-labelledby="protocol-info-title"
          hidden="hidden"
        >
        <header class="protocol-info-header">
          <div class="protocol-info-header__titles">
            <p class="protocol-info-subtitle" data-testid="protocol-info-subtitle">Protocol guidance</p>
            <h2 class="protocol-info-title" data-testid="protocol-info-title">OCRA (OATH Challenge-Response Algorithm)</h2>
          </div>
          <div class="protocol-info-header__actions">
            <button
                type="button"
                class="protocol-info-action"
                data-testid="protocol-info-expand"
                aria-label="Expand to modal"
              >
              Expand
            </button>
            <button
                type="button"
                class="protocol-info-action protocol-info-action--primary"
                data-testid="protocol-info-close"
                aria-label="Close protocol info"
              >
              Close
            </button>
          </div>
        </header>
        <div class="protocol-info-body">
          <div class="protocol-info-summary" data-testid="protocol-info-summary"></div>
          <div class="protocol-info-accordion" data-testid="protocol-info-accordion"></div>
        </div>
      </aside>
    </main>

    <script type="application/json" id="protocol-info-data">
      {
        "protocols": {
          "ocra": {
            "title": "OCRA (OATH Challenge-Response Algorithm)",
            "subtitle": "Challenge-response credential operations",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "OCRA (RFC 6287) derives one-time responses by hashing a keyed secret with a challenge payload, enabling transaction signing and high-assurance verification windows.",
                  "The simulator implements the suite-driven descriptor model used across MapDB-backed credential stores and facade integrations."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Select an RFC 6287 suite that defines data inputs and truncation rules.",
                  "Collect inputs (counter, timestamp, challenge, PIN, session) and normalise to byte arrays.",
                  "Concatenate the suite-defined data fields and compute an HMAC using the shared secret.",
                  "Truncate the HMAC response to the requested digit length and format as the final OTP.",
                  "Validate by recomputing the response and comparing constant-time across allowed drift windows."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Suites use the format OCRAnnn-h-m, where data descriptors declare counter (C), question (Q), password (P), session (S), and timestamp (T) inputs.",
                  "Challenge questions accept Hex, Alphanumeric, or Numeric payloads; simulator inputs request the canonical representation needed for each suite.",
                  "Responses truncate to 4–10 digits; the simulator exposes 8 and 10 digit defaults for operator workflows."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "Rotate shared secrets when challenge payloads leak or counters desynchronise beyond replay windows.",
                  "Reject challenges that exceed maximum length (512 bytes) to avoid resource exhaustion.",
                  "Protect transport of challenge payloads; MITM modification yields fraudulent signatures."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "RFC 6287 – OCRA", "url": "https://www.rfc-editor.org/rfc/rfc6287" },
                  { "label": "NIST SP 800-63B", "url": "https://pages.nist.gov/800-63-3/sp800-63b.html" },
                  { "label": "OpenAuth Simulator OCRA samples", "url": "https://example.com/docs/ocra-samples" }
                ]
              }
            ]
          },
          "hotp": {
            "title": "HOTP (HMAC-Based One-Time Password)",
            "subtitle": "Event counter driven OTP",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "HOTP (RFC 4226) increments a moving counter shared between client and verifier to derive HMAC-based OTP values.",
                  "The simulator will expose counter management helpers once HOTP issuance ships."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Derive a counter value shared between client and server.",
                  "Compute HMAC-SHA-1 over the 8-byte counter and truncate per RFC 4226 dynamic truncation.",
                  "Compare OTP values within a resynchronisation window to tolerate drift."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Counters increment monotonically; resets demand secret rotation.",
                  "Digits commonly configured at 6 or 8; RFC 4226 permits 6–10.",
                  "Secrets are Base32-encoded for provisioning (per Key URI format)."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "High drift windows expand brute-force exposure; keep look-ahead ≤30.",
                  "Store counters atomically to avoid replay vulnerabilities after verification failures.",
                  "Limit OTP retry attempts and introduce back-off for online verification."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "RFC 4226 – HOTP", "url": "https://www.rfc-editor.org/rfc/rfc4226" },
                  { "label": "Key URI Format", "url": "https://github.com/google/google-authenticator/wiki/Key-Uri-Format" }
                ]
              }
            ]
          },
          "totp": {
            "title": "TOTP (Time-Based One-Time Password)",
            "subtitle": "Time window OTP",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "TOTP (RFC 6238) extends HOTP by deriving the moving factor from Unix time segments, typically 30-second steps.",
                  "Operator tooling will surface drift diagnostics and skew detection when the facade ships."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Quantise current time into step windows (default 30 seconds).",
                  "Compute HMAC using the shared secret and the time step counter.",
                  "Apply dynamic truncation and format digits for display."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Supported hash algorithms: SHA-1, SHA-256, SHA-512.",
                  "Common digit lengths: 6 or 8; align with relying-party expectations.",
                  "Allow ±1 window drift by default; adjust for device skew after telemetry review."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "Block token reuse within the same window to mitigate race conditions.",
                  "Monitor for monotonic clock skew; sync frequently on mobile hardware.",
                  "Prefer SHA-256+ for high assurance to avoid SHA-1 collision concerns."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "RFC 6238 – TOTP", "url": "https://www.rfc-editor.org/rfc/rfc6238" },
                  { "label": "NIST SP 800-63B", "url": "https://pages.nist.gov/800-63-3/sp800-63b.html" }
                ]
              }
            ]
          },
          "emv": {
            "title": "EMV / CAP", "subtitle": "Cardholder authentication program",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "EMV/CAP authenticators rely on smart cards that derive responses from transaction challenge data.",
                  "The simulator will mirror issuer scripts and response parsing in a future increment."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Reader prompts the cardholder to insert the EMV card and enter the PIN.",
                  "Terminal constructs a challenge (ATC, amount, currency) and sends to the card applet.",
                  "Card signs the payload, returning a CAP result that the bank verifies."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Application Transaction Counter (ATC) increments for each authorization attempt.",
                  "Transaction data encoded using BCD; issuer script maps to CAP format codes.",
                  "Result codes map to response types (Signature, Identify, Respond, Challenge)."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "Protect offline PIN verification channels; fallback to online PIN when risk high.",
                  "Monitor ATC gaps for potential relay or clone events.",
                  "Enforce timeouts between challenge issuance and response submission."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "EMV Book 3", "url": "https://www.emvco.com/specifications/" },
                  { "label": "CAP Specification", "url": "https://www.emvco.com/emv-technologies/cardholder-authentication-program/" }
                ]
              }
            ]
          },
          "fido2": {
            "title": "FIDO2 / WebAuthn",
            "subtitle": "Passkey-style public key assertions",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "FIDO2 unifies WebAuthn (client) and CTAP (authenticator) protocols to deliver phishing-resistant authentication.",
                  "Upcoming simulator flows will replay attestation and assertion ceremonies for operator testing."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Relying party issues a challenge and conveys relying-party ID and user info.",
                  "Authenticator signs the challenge with a private key scoped to the RP ID.",
                  "Server validates the signature, origin, and counter increments."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Credential sources carry RP ID hash, user handle, credential ID, and public key.",
                  "Authenticator data encodes the sign count and extension flags.",
                  "Client data JSON binds challenge, origin, and type (webauthn.get / .create)."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "Track signature counter regressions to detect cloned authenticators.",
                  "Always verify client extensions (appid, credProps) according to RP policy.",
                  "Prefer platform authenticators with UV or passkeys for step-up auth."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "W3C WebAuthn", "url": "https://www.w3.org/TR/webauthn-2/" },
                  { "label": "FIDO2 CTAP", "url": "https://fidoalliance.org/specifications/" }
                ]
              }
            ]
          },
          "eudi-openid4vp": {
            "title": "EUDIW OpenID4VP 1.0",
            "subtitle": "Verifiable presentation exchange",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "OpenID4VP enables wallet-to-verifier presentation of verifiable credentials defined in the EUDI architecture.",
                  "Simulator coverage will illustrate presentation definitions and response validation."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Verifier issues an authorization request embedding presentation definition requirements.",
                  "Wallet selects credentials that satisfy input descriptors and returns a signed VP token.",
                  "Verifier validates proofs, issuer signatures, and audience bindings."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Presentation definitions structure: input_descriptors, constraints, format filters.",
                  "VP token carries verifiablePresentation and presentation_submission members.",
                  "Responses conveyed over back-channel or front-channel depending on client type."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "Enforce audience binding between request_uri and presentation submission.",
                  "Rotate presentation exchange nonces per session.",
                  "Validate descriptor_map entries to guard against mismatched credentials."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "OpenID4VP 1.0", "url": "https://openid.net/specs/openid-4-verifiable-presentations-1_0.html" },
                  { "label": "EUDI Architecture", "url": "https://digital-strategy.ec.europa.eu/en/policies/eudi-wallet" }
                ]
              }
            ]
          },
          "eudi-iso-18013-5": {
            "title": "EUDIW ISO/IEC 18013-5",
            "subtitle": "Mobile driving licence presentations",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "ISO/IEC 18013-5 governs mobile driving licence (mDL) credential presentation workflows leveraged by the EUDI wallet.",
                  "Future simulator flows will generate device engagement and reader session payloads."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Reader and device establish secure session via NFC, BLE, or QR engagement.",
                  "Reader sends a device request listing data elements and authentication options.",
                  "Device signs response items and returns a Mobile Security Object (MSO)."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Device engagement data encodes reader public keys and session IDs.",
                  "MSO contains metadata version, digest algorithm, and signed data element digests.",
                  "Presentation responses carry device signatures plus reader authentication status."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "Enforce per-session key confirmation to block relay attacks.",
                  "Limit disclosed data elements to the minimum requested scope.",
                  "Verify issuer certificate chains per country-specific trust lists."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "ISO/IEC 18013-5", "url": "https://www.iso.org/standard/69084.html" },
                  { "label": "ISO/IEC 23220-4 draft", "url": "https://www.iso.org/committee/45144.html" }
                ]
              }
            ]
          },
          "eudi-siopv2": {
            "title": "EUDIW SIOPv2",
            "subtitle": "Self-issued OpenID Provider",
            "sections": [
              {
                "key": "overview",
                "heading": "Overview",
                "defaultOpen": true,
                "paragraphs": [
                  "SIOPv2 lets wallets act as self-issued OpenID Providers, returning ID token responses scoped to verifier requests.",
                  "Simulator coverage plans to visualise DID document resolution and credential binding."
                ]
              },
              {
                "key": "how-it-works",
                "heading": "How it works",
                "steps": [
                  "Verifier issues an OIDC authentication request referencing self-issued client metadata.",
                  "Wallet resolves its DID document, constructs an ID token with requested claims, and signs using the DID key.",
                  "Verifier validates the DID signature and correlates presentation responses where required."
                ]
              },
              {
                "key": "parameters",
                "heading": "Parameters & formats",
                "bullets": [
                  "Self-issued clients signal subject identifiers via did: or jkt claims.",
                  "Nonce and state parameters bind the authentication to the verifier session.",
                  "Responses may embed verifiable presentations via presentation_submission."
                ]
              },
              {
                "key": "security",
                "heading": "Security notes & pitfalls",
                "bullets": [
                  "Validate DID key agreement and rotate keys when compromised.",
                  "Reject unsigned or weakly signed ID tokens (alg=none).",
                  "Mitigate correlation: provide pairwise identifiers for each verifier relying party."
                ]
              },
              {
                "key": "references",
                "heading": "Specifications & test vectors",
                "links": [
                  { "label": "OpenID SIOPv2", "url": "https://openid.net/specs/openid-connect-self-issued-v2-1_0.html" },
                  { "label": "Decentralized Identifiers (DID Core)", "url": "https://www.w3.org/TR/did-core/" }
                ]
              }
            ]
          }
        }
      }
    </script>
    <th:block th:replace="~{ui/ocra/evaluate :: ocraEvaluateScripts}"></th:block>
    <th:block th:replace="~{ui/ocra/replay :: ocraReplayScripts}"></th:block>
    <script th:src="@{/ui/shared/result-card.js}"></script>
    <script th:src="@{/ui/protocol-info.js}"></script>
    <script th:src="@{/ui/shared/verbose-trace.js}"></script>
    <script th:src="@{/ui/shared/secret-fields.js}"></script>
    <script th:src="@{/ui/console/console.js}"></script>
    <script th:src="@{/ui/hotp/console.js}"></script>
    <script th:src="@{/ui/totp/console.js}"></script>
    <script th:src="@{/ui/fido2/console.js}"></script>
  </body>
</html>
